use std::iter::Peekable;

use crate::compiler::context::frontend::CompilerFrontendContext;
use crate::compiler::symbol::Symbol;
use crate::parser::errors::ParseErr;
use crate::parser::ast::{self as AST};
use crate::tokenizer::tokens::{Delimiter, Keyword, Literal, Operator, Token};

/// A parser for the Hydent programming language.
///
/// This struct holds the tokenizer's output and the compiler frontend context,
/// and provides methods for parsing the token stream into an Abstract Syntax Tree (AST).
pub struct Parser<'ctx, I>
where
    I: Iterator<Item = Token>,
{
    tokens: Peekable<I>,
    errors: Vec<ParseErr>,
    ctx: CompilerFrontendContext<'ctx>,
}

type Return<T> = Result<T, ParseErr>;

/// Implementation of the `Parser` for the Hydent programming language.
///
/// This block contains the core parsing logic, including methods to
/// consume tokens, handle parsing errors, and construct the Abstract
/// Syntax Tree (AST) from the token stream.
impl<'ctx, I> Parser<'ctx, I>
where
    I: Iterator<Item = Token>,
{
    /// Creates a new `Parser` instance.
    ///
    /// Initializes the parser with a peekable token iterator and a compiler frontend context.
    /// The error list is initialized as empty.
    ///
    /// # Arguments
    ///
    /// * `tokens` - A `Peekable` iterator over the tokens generated by the tokenizer.
    /// * `ctx` - The `CompilerFrontendContext` providing compiler-wide information.
    pub fn new(tokens: Peekable<I>, ctx: CompilerFrontendContext<'ctx>) -> Self {
        Self {
            tokens,
            errors: Vec::new(),
            ctx,
        }
    }

    fn next(&mut self, token: Token) -> Return<()> {
        if self.tokens.peek() == Some(&token) {
            Ok(())
        } else {
            Err(ParseErr::UnexpectedToken(token))
        }
    }

    pub fn parse(mut self) -> Return<AST::Ast> {
        self.parse_ast()
    }

    fn parse_ast(&mut self) -> Return<AST::Ast> {
        Ok(AST::Ast {
            declarations: self
                .ctx
                .arena
                .alloc_with(|| self.parse_top_level_declaration().ok()),
        })
    }

    fn parse_top_level_declaration(&mut self) -> Return<AST::TopLevelDeclaration> {
        match self.tokens.peek() {
            Some(Token::Keyword(Keyword::Fn)) => Ok(AST::TopLevelDeclaration::Function(
                if let Ok(function_declaration) = self.parse_function_declaration() {
                    self.tokens.next();
                    self.ctx.arena.alloc(function_declaration)
                } else {
                    return Err(ParseErr::UnexpectedToken(
                        self.tokens.peek().unwrap().clone(),
                    ));
                },
            )),
            _ => Err(ParseErr::UnexpectedToken(
                self.tokens.peek().unwrap().clone(),
            )),
        }
    }

    fn parse_function_declaration(&mut self) -> Return<AST::FunctionDeclaration> {
        self.next(Token::Keyword(Keyword::Fn))?;
        let name = self.parse_identifier()?;
        self.next(Token::Delimiter(Delimiter::LeftParen))?;
        let params = self.ctx.arena.alloc_with(|| self.parse_parameter().ok());
        self.next(Token::Delimiter(Delimiter::RightParen))?;
        let return_type = if self.next(Token::Operator(Operator::Colon)).is_ok() {
            Some(self.parse_type_literal()?)
        } else {
            None
        };
        let body = self.parse_block_expression()?;
        let body = self.ctx.arena.alloc(body);
        Ok(AST::FunctionDeclaration {
            name,
            params,
            return_type,
            body,
        })
    }

    fn parse_identifier(&mut self) -> Return<Symbol> {
        if let Some(Token::Identifier(ref symbol)) = self.tokens.peek() {
            Ok(*symbol)
        } else {
            Err(ParseErr::ExpectIdentifier)
        }
    }

    fn parse_parameter(&mut self) -> Return<AST::FunctionParameter> {
        let name = self.parse_identifier()?;
        self.next(Token::Operator(Operator::Colon))?;
        let type_literal = self.parse_type_literal()?;
        Ok(AST::FunctionParameter { name, type_literal })
    }

    fn parse_type_literal(&mut self) -> Return<AST::TypeLiteral> {
        match self.tokens.next() {
            Some(Token::Keyword(Keyword::Int)) => Ok(AST::TypeLiteral::Int),
            _ => Err(ParseErr::UnexpectedToken(
                self.tokens.peek().unwrap().clone(),
            )),
        }
    }

    fn parse_block_expression(&mut self) -> Return<AST::BlockExpression> {
        self.next(Token::Delimiter(Delimiter::LeftBrace))?;
        let statements = self.ctx.arena.alloc_with(|| self.parse_statement().ok());
        match self.next(Token::Delimiter(Delimiter::RightBrace)) {
            Ok(_) => Ok(AST::BlockExpression {
                statements,
                final_expr: None,
            }),
            Err(_) => {
                let final_expr = self.ctx.arena.alloc(self.parse_expression()?);
                self.next(Token::Delimiter(Delimiter::RightBrace))?;
                Ok(AST::BlockExpression {
                    statements,
                    final_expr: Some(final_expr),
                })
            }
        }
    }

    fn parse_statement(&mut self) -> Return<AST::Statement> {
        match self.tokens.peek() {
            Some(Token::Keyword(Keyword::Let)) => Ok(AST::Statement::Assignment(
                self.ctx.arena.alloc(self.parse_assignment_statement()?),
            )),
            Some(Token::Keyword(Keyword::Return)) => Ok(AST::Statement::Return(
                self.ctx.arena.alloc(self.parse_return_statement()?),
            )),
            _ => Err(ParseErr::UnexpectedToken(
                self.tokens.peek().unwrap().clone(),
            )),
        }
    }

    fn parse_expression(&mut self) -> Return<AST::Expression> {
        match self.tokens.peek() {
            Some(Token::Literal(Literal::IntegerLiteral(int))) => {
                Ok(AST::Expression::Literal(AST::Literal::Integer(*int)))
            }
            Some(Token::Identifier(_)) => Ok(AST::Expression::FunctionCall(
                self.ctx.arena.alloc(self.parse_function_call()?),
            )),
            _ => Err(ParseErr::ExpectIdentifier),
        }
    }

    fn parse_assignment_statement(&mut self) -> Return<AST::AssignmentStatement> {
        match self.tokens.peek() {
            Some(Token::Keyword(Keyword::Let)) => {
                self.next(Token::Keyword(Keyword::Let))?;
                let name = self.parse_identifier()?;
                self.next(Token::Operator(Operator::Equality))?;
                let value = self.ctx.arena.alloc(self.parse_expression()?);
                Ok(AST::AssignmentStatement { name, value })
            }
            _ => Err(ParseErr::ExpectIdentifier),
        }
    }

    fn parse_return_statement(&mut self) -> Return<AST::ReturnStatement> {
        self.next(Token::Keyword(Keyword::Return))?;
        if let Ok(_) = self.next(Token::Delimiter(Delimiter::Semicolon)) {
            Ok(AST::ReturnStatement { value: None })
        } else {
            let value = Some(self.ctx.arena.alloc(self.parse_expression()?));
            Ok(AST::ReturnStatement { value })
        }
    }

    fn parse_function_call(&mut self) -> Return<AST::FunctionCall> {
        let name = self.parse_identifier()?;
        self.next(Token::Delimiter(Delimiter::LeftParen))?;

        let mut has_error = false;
        let mut expect_next = true;

        let args = self.ctx.arena.alloc_with(|| {
            if has_error {
                return None;
            }
            if self.tokens.peek() == Some(&Token::Delimiter(Delimiter::RightParen)) {
                return None;
            }
            let expr = match self.parse_expression() {
                Ok(e) => e,
                Err(_) => {
                    has_error = true;
                    return None;
                }
            };
            let is_next_comma = self.next(Token::Delimiter(Delimiter::Comma)).is_ok();
            expect_next = is_next_comma;

            Some(expr)
        });
        self.next(Token::Delimiter(Delimiter::RightParen))?;
        if has_error {
            Err(ParseErr::ExpectIdentifier)
        } else {
            Ok(AST::FunctionCall { name, args })
        }
    }
}
