use std::iter::Peekable;

use crate::compiler::arena::{Arena, ArenaVec};
use crate::compiler::context::frontend::CompilerFrontendContext;
use crate::parser as AST;
use crate::parser::errors::ParseErr;
use crate::tokenizer::{Comment, Delimiter, Keyword, Literal, Operator, Token};

/// A parser for the Hydent programming language.
///
/// This struct holds the tokenizer's output and the compiler frontend context,
/// and provides methods for parsing the token stream into an Abstract Syntax Tree (AST).
pub struct Parser<'src, I>
where
    I: Iterator<Item = Token>,
{
    tokens: Peekable<I>,
    errors: Vec<ParseErr>,
    ctx: CompilerFrontendContext<'src>,
}

type Return<T> = Result<T, ParseErr>;

/// Implementation of the `Parser` for the Hydent programming language.
///
/// This block contains the core parsing logic, including methods to
/// consume tokens, handle parsing errors, and construct the Abstract
/// Syntax Tree (AST) from the token stream.
impl<'src, I> Parser<'src, I>
where 
    I: Iterator<Item = Token>,
{
    /// Creates a new `Parser` instance.
    ///
    /// Initializes the parser with a peekable token iterator and a compiler frontend context.
    /// The error list is initialized as empty.
    ///
    /// # Arguments
    ///
    /// * `tokens` - A `Peekable` iterator over the tokens generated by the tokenizer.
    /// * `ctx` - The `CompilerFrontendContext` providing compiler-wide information.
    pub fn new(tokens: Peekable<I>, ctx: CompilerFrontendContext) -> Self {
        Self {
            tokens,
            errors: Vec::new(),
            ctx,
        }
    }

    /// Consumes the next token if it matches the `expected` token.
    ///
    /// This function peeks at the next token. If it matches `expected`,
    /// the token is consumed and `Ok(())` is returned. Otherwise, an
    /// `Err(ParseErr)` is returned without consuming the token.
    ///
    /// # Arguments
    ///
    /// * `expected` - The `Token` type that is expected next in the stream.
    ///
    /// # Returns
    ///
    /// `Ok(())` if the expected token is found and consumed, `Err(ParseErr)` otherwise.
    #[inline]
    fn next(&mut self, expected: Token) -> Return<()> {
        if let Some(next_token) = self.tokens.peek() {
            if *next_token == expected {
                self.tokens.next();
                return Ok(());
            }
        }
        Err(ParseErr)
    }

    /// Returns a reference to the current token without consuming it.
    ///
    /// This is useful for looking ahead in the token stream to make parsing decisions.
    ///
    /// # Returns
    ///
    /// An `Option<&Token>` which is `Some(&Token)` if there is a current token,
    /// or `None` if the end of the token stream has been reached.
    #[inline]
    fn now_token(&mut self) -> Option<&Token> {
        self.tokens.peek()
    }

    /// Attempts to recover from a parsing error by advancing the token stream.
    ///
    /// This method is typically called after a parsing error is encountered.
    /// It skips tokens until a known synchronization point is reached,
    /// attempting to bring the parser back into a valid state.
    fn synchronize(&mut self) -> Return<()> {
        unimplemented!()
    }

    /// Parses the token stream into an Abstract Syntax Tree (AST).
    ///
    /// This method is the main entry point for parsing
    pub fn parse(&mut self) -> Result<AST::Ast<'_>, Vec<ParseErr>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <ast> ::= <top_level>
    /// ```
    fn parse_ast(&mut self) -> Return<AST::Ast<'_>> {
        let top_level = self.parse_top_level()?;
        Ok(AST::Ast { top_level })
    }

    /// ```ebnf
    /// <top_level> ::= { <top_level_statement> }
    /// ```
    fn parse_top_level(&mut self) -> Return<AST::TopLevel<'_>> {
        let mut children = self.ctx.arena().alloc_vec(0, 1);
        while let Ok(top_level_statement) = self.parse_top_level_statement() {
            children.push(top_level_statement);
        }
        Ok(AST::TopLevel { children: children })
    }

    /// ```ebnf
    /// <top_level_statement> ::=
    ///        <import_declaration>
    ///      | <static_variable_declaration>
    ///      | <class_declaration>
    ///      | <enum_declaration>
    ///      | <struct_declaration>
    ///      | <function_declaration>
    ///      | <protocol_declaration>
    ///      | <module_declaration>
    ///      | <annotation>
    ///      | <type_alias_declaration>
    /// ```
    fn parse_top_level_statement(&mut self) -> Return<AST::TopLevelStatement<'_>> {
        if let Ok(import_declaration) = self.parse_import_declaration() {
            Ok(AST::TopLevelStatement::ImportDeclaration(
                import_declaration,
            ))
        } else if let Ok(static_variable_declaration) = self.parse_static_variable_declaration() {
            Ok(AST::TopLevelStatement::StaticVariableDeclaration(
                static_variable_declaration,
            ))
        } else if let Ok(class_declaration) = self.parse_class_declaration() {
            Ok(AST::TopLevelStatement::ClassDeclaration(class_declaration))
        } else if let Ok(enum_declaration) = self.parse_enum_declaration() {
            Ok(AST::TopLevelStatement::EnumDeclaration(enum_declaration))
        } else if let Ok(struct_declaration) = self.parse_struct_declaration() {
            Ok(AST::TopLevelStatement::StructDeclaration(
                struct_declaration,
            ))
        } else if let Ok(function_declaration) = self.parse_function_declaration() {
            Ok(AST::TopLevelStatement::FunctionDeclaration(
                function_declaration,
            ))
        } else if let Ok(protocol_declaration) = self.parse_protocol_declaration() {
            Ok(AST::TopLevelStatement::ProtocolDeclaration(
                protocol_declaration,
            ))
        } else if let Ok(module_declaration) = self.parse_module_declaration() {
            Ok(AST::TopLevelStatement::ModuleDeclaration(
                module_declaration,
            ))
        } else if let Ok(annotation) = self.parse_annotation() {
            Ok(AST::TopLevelStatement::Annotation(annotation))
        } else if let Ok(type_alias_declaration) = self.parse_type_alias_declaration() {
            Ok(AST::TopLevelStatement::TypeAliasDeclaration(
                type_alias_declaration,
            ))
        } else {
            Err(ParseErr::UnexpectedToken {
                message: "Unknown token",
                expected: Vec::new(),
                found: self.now_token(),
            })
        }
    }

    /// ```ebnf
    /// <import_declaration> ::= "import" ( <import_specific> | <import_all_as> ) "from" <STRING_LITERAL> ";"
    /// ```
    fn parse_import_declaration(&mut self) -> Return<AST::ImportDeclaration<'_>> {
        if self.next(Token::Keyword(Keyword::Import)).is_ok() {
            if let Ok(import_specific) = self.parse_import_specific() {
                if self.next(Token::Keyword(Keyword::From)).is_ok() {
                    if let Some(Token::Literal(Literal::StringLiteral(path))) = self.now_token() {
                        Ok(AST::ImportDeclaration::ImportSpecific(
                            import_specific,
                            path,
                        ))
                    } else {
                        Err(ParseErr::UnexpectedToken {
                            message: "",
                            expected: vec![Token::Literal(Literal::StringLiteral(""))],
                            found: self.now_token(),
                        })
                    }
                } else {
                    Err(ParseErr::UnexpectedToken {
                        message: "",
                        expected: vec![Token::Keyword(Keyword::From)],
                        found: self.now_token(),
                    })
                }
            } else if let Ok(import_all_as) = self.parse_import_all_as() {
                if self.next(Token::Keyword(Keyword::From)).is_ok() {
                    if let Some(Token::Literal(Literal::StringLiteral(path))) = self.now_token() {
                        Ok(AST::ImportDeclaration::ImportAllAs(import_all_as, path))
                    } else {
                        Err(ParseErr::UnexpectedToken {
                            message: "",
                            expected: vec![Token::Literal(Literal::StringLiteral(""))],
                            found: self.now_token(),
                        })
                    }
                } else {
                    Err(ParseErr::UnexpectedToken {
                        message: "",
                        expected: vec![Token::Keyword(Keyword::From)],
                        found: self.now_token(),
                    })
                }
            } else {
                Err(ParseErr::UnexpectedToken {
                    message: "",
                    expected: vec![
                        Token::Identifier(""),
                        Token::Delimiter(Delimiter::LeftBrace),
                    ],
                    found: self.now_token(),
                })
            }
        } else {
            Err(ParseErr::UnexpectedToken {
                message: "",
                expected: vec![Token::Keyword(Keyword::Import)],
                found: self.now_token(),
            })
        }
    }

    /// ```ebnf
    /// <import_specific> ::= "{" <identifier_list> "}"
    /// ```
    fn parse_import_specific(&mut self) -> Return<AST::ImportSpecific<'_>> {
        if self.next(Token::Delimiter(Delimiter::LeftBrace)).is_err() {
            return Err(ParseErr::UnexpectedToken {
                message: "",
                expected: vec![Token::Delimiter(Delimiter::LeftBrace)],
                found: self.now_token(),
            });
        }
        if let Ok(identifier_list) = self.parse_identifier_list() {
            if self.next(Token::Delimiter(Delimiter::RightBrace)).is_ok() {
                Ok(AST::ImportSpecific(identifier_list))
            } else {
                Err(ParseErr::UnexpectedToken {
                    message: "",
                    expected: vec![Token::Delimiter(Delimiter::RightBrace)],
                    found: self.now_token(),
                })
            }
        } else {
            Err(ParseErr::UnexpectedToken {
                message: "",
                expected: vec![Token::Identifier("")],
                found: self.now_token(),
            })
        }
    }

    /// ```ebnf
    /// <import_all_as> ::= "*" "as" <IDENTIFIER>
    /// ```
    fn parse_import_all_as(&mut self) -> Return<AST::ImportAllAs<'_>> {
        if self.next(Token::Operator(Operator::Multiply)).is_ok() && self.next(Token::Keyword(Keyword::As)).is_ok()
        {
            if let Some(Token::Identifier(identifier_str)) = self.now_token() {
                Ok(AST::ImportAllAs(AST::Identifier(identifier_str)))
            } else {
                Err(ParseErr::UnexpectedToken {
                    message: "",
                    expected: vec![Token::Identifier("")],
                    found: self.now_token(),
                })
            }
        } else {
            Err(ParseErr::UnexpectedToken {
                message: "",
                expected: vec![
                    Token::Operator(Operator::Multiply),
                    Token::Keyword(Keyword::As),
                    Token::Identifier(""),
                ],
                found: self.now_token(),
            })
        }
    }

    /// ```ebnf
    /// <static_variable_declaration> ::= <docs_comments> <is_public> "static" <IDENTIFIER> "=" <expression> ";"
    /// ```
    fn parse_static_variable_declaration(&mut self) -> Return<AST::StaticVariableDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <class_declaration> ::= <docs_comments> <is_public> "class" <IDENTIFIER> <generics> <implements_protocol> "{" { <function_declaration> | <field_declaration> | <type_alias_declaration> } "}"
    /// ```
    fn parse_class_declaration(&mut self) -> Return<AST::ClassDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <enum_declaration> ::= <docs_comments> <is_public> "enum" <IDENTIFIER> <generics> <implements_protocol> "{" { <enum_member> } "}"
    /// ```
    fn parse_enum_declaration(&mut self) -> Return<AST::EnumDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <enum_member> ::= <enum_variant> | <function_declaration>
    /// ```
    fn parse_enum_member(&mut self) -> Return<AST::EnumMember<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <enum_variant> ::= <IDENTIFIER> ( "(" <type_literal_list> ")" )?
    /// ```
    fn parse_enum_variant(&mut self) -> Return<AST::EnumVariant<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_declaration> ::= <docs_comments> <is_public> "struct" <IDENTIFIER> <struct_body>
    /// ```
    fn parse_struct_declaration(&mut self) -> Return<AST::StructDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_body> ::= <struct_block_body> | <struct_tuple_body> | ";"
    /// ```
    fn parse_struct_body(&mut self) -> Return<AST::StructBody<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_block_body> ::= "{" { <field_declaration> } "}"
    /// ```
    fn parse_struct_block_body(&mut self) -> Return<AST::StructBlockBody<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_tuple_body> ::= "(" <type_literal_list> ")"
    /// ```
    fn parse_struct_tuple_body(&mut self) -> Return<AST::StructTupleBody<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <function_declaration> ::= <docs_comments> "extern"? <is_public> "async"? "fn" <IDENTIFIER> <generics> "(" <params_with_types>  ")" ( "->" <type_literal> )? "panics"? <block_expression>?
    /// ```
    fn parse_function_declaration(&mut self) -> Return<AST::FunctionDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <protocol_declaration> ::= <docs_comments> <is_public> "protocol" <IDENTIFIER> <implements_protocol> "{" { <protocol_member> } "}"
    /// ```
    fn parse_protocol_declaration(&mut self) -> Return<AST::ProtocolDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <protocol_member> ::= <function_declaration> | <type_alias_declaration>
    /// ```
    fn parse_protocol_member(&mut self) -> Return<AST::ProtocolMember<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <module_declaration> ::= <docs_comments> <is_public> "module" <IDENTIFIER> "{" <top_level> "}"
    /// ```
    fn parse_module_declaration(&mut self) -> Return<AST::ModuleDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <annotation> ::= "@" <IDENTIFIER<'_>> { <literal> }
    /// ```
    fn parse_annotation(&mut self) -> Return<AST::Annotation<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <type_alias_declaration> ::= <docs_comments> <is_public> "type" <IDENTIFIER> <generics>? "=" <type_literal> ";"
    /// ```
    fn parse_type_alias_declaration(&mut self) -> Return<AST::TypeAliasDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <if_expression> ::= "if" <expression> <block_expression<'_>> { <else_if_clause> } <else_clause>?
    /// ```
    fn parse_if_expression(&mut self) -> Return<AST::IfExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <else_if_clause> ::= "else" "if" <expression> <block_expression>
    /// ```
    fn parse_else_if_clause(&mut self) -> Return<AST::ElseIfClause<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <else_clause> ::= "else" <block_expression>
    /// ```
    fn parse_else_clause(&mut self) -> Return<AST::ElseClause<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <match_expression> ::= "match" <expression> "{" { <match_arm> } "}"
    /// ```
    fn parse_match_expression(&mut self) -> Return<AST::MatchExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <match_arm> ::= <pattern> ( "if" <expression> )? "=>" <expression>
    /// ```
    fn parse_match_arm(&mut self) -> Return<AST::MatchArm<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <loop_expression> ::= "loop" <expression>? <block_expression>
    /// ```
    fn parse_loop_expression(&mut self) -> Return<AST::LoopExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <while_expression> ::= "while" <expression> <block_expression>
    /// ```
    fn parse_while_expression(&mut self) -> Return<AST::WhileExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <for_statement> ::= "for" <pattern> "in" <expression> <block_expression>
    /// ```
    fn parse_for_statement(&mut self) -> Return<AST::ForStatement<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <for_expression> ::= "for" <expression> "{" { <pipeline_arm> } "}"
    /// ```
    fn parse_for_expression(&mut self) -> Return<AST::ForExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <pipeline_arm> ::= "|>" <pattern> "=>" <expression>
    /// ```
    fn parse_pipeline_arm(&mut self) -> Return<AST::PipelineArm<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <if_let_expression> ::= "if" "let" <pattern> "=" <expression> <block_expression>
    /// ```
    fn parse_if_let_expression(&mut self) -> Return<AST::IfLetExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <while_let_expression> ::= "while" "let" <pattern> "=" <expression> <block_expression>
    /// ```
    fn parse_while_let_expression(&mut self) -> Return<AST::WhileLetExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <pipe_expression> ::= "pipe" <expression> "{" { <pipe_arm> } "}"
    /// ```
    fn parse_pipe_expression(&mut self) -> Return<AST::PipeExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <pipe_arm> ::= "|>" <pattern> ("if" <expression>)? "=>" <expression>
    /// ```
    fn parse_pipe_arm(&mut self) -> Return<AST::PipeArm<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <closer> ::= "(" <closer_params>? ")" "->" <expression>
    /// ```
    fn parse_closer(&mut self) -> Return<AST::Closer<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <closer_params> ::= <closer_param_item<'_>> { "," <closer_param_item> }
    /// ```
    fn parse_closer_params(&mut self) -> Return<AST::CloserParams<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <closer_param_item> ::= <param_with_type> | <IDENTIFIER>
    /// ```
    fn parse_closer_param_item(&mut self) -> Return<AST::CloserParamItem<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <accesser> ::= <IDENTIFIER<'_>> { "::" <IDENTIFIER> }
    /// ```
    fn parse_accesser(&mut self) -> Return<AST::Accesser<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <params> ::= <expression_list>?
    /// ```
    fn parse_params(&mut self) -> Return<AST::Params<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <expression> ::= <logical_or_expr>
    /// ```
    fn parse_expression(&mut self) -> Return<AST::Expression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <logical_or_expr> ::= <logical_and_expr<'_>> { "||" <logical_and_expr> }
    /// ```
    fn parse_logical_or_expr(&mut self) -> Return<AST::LogicalOrExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <logical_and_expr> ::= <bitwise_or_expr<'_>> { "&&" <bitwise_or_expr> }
    /// ```
    fn parse_logical_and_expr(&mut self) -> Return<AST::LogicalAndExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <bitwise_or_expr> ::= <bitwise_xor_expr<'_>> { "|" <bitwise_xor_expr> }
    /// ```
    fn parse_bitwise_or_expr(&mut self) -> Return<AST::BitwiseOrExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <bitwise_xor_expr> ::= <bitwise_and_expr<'_>> { "^" <bitwise_and_expr> }
    /// ```
    fn parse_bitwise_xor_expr(&mut self) -> Return<AST::BitwiseXorExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <bitwise_and_expr> ::= <equality_expr<'_>> { "&" <equality_expr> }
    /// ```
    fn parse_bitwise_and_expr(&mut self) -> Return<AST::BitwiseAndExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <equality_expr> ::= <relational_expr<'_>> { ("==" | "!=") <relational_expr> }
    /// ```
    fn parse_equality_expr(&mut self) -> Return<AST::EqualityExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <relational_expr> ::= <shift_expr<'_>> { ("<" | "<=" | ">" | ">=") <shift_expr> }
    /// ```
    fn parse_relational_expr(&mut self) -> Return<AST::RelationalExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <shift_expr> ::= <additive_expr<'_>> { ("<<" | ">>") <additive_expr> }
    /// ```
    fn parse_shift_expr(&mut self) -> Return<AST::ShiftExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <additive_expr> ::= <multiplicative_expr<'_>> { ("+" | "-") <multiplicative_expr> }
    /// ```
    fn parse_additive_expr(&mut self) -> Return<AST::AdditiveExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <multiplicative_expr> ::= <power_expr<'_>> { ("*" | "/" | "%") <power_expr> }
    /// ```
    fn parse_multiplicative_expr(&mut self) -> Return<AST::MultiplicativeExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <power_expr> ::= <prefix_expr<'_>> { "**" <prefix_expr> }
    /// ```
    fn parse_power_expr(&mut self) -> Return<AST::PowerExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <prefix_expr> ::= (("!" | "~" | "-") <prefix_expr>) | <primary_expr>
    /// ```
    fn parse_prefix_expr(&mut self) -> Return<AST::PrefixExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <primary_expr> ::=
    ///      <block_expression>
    ///    | <if_expression>
    ///    | <match_expression>
    ///    | <loop_expression>
    ///    | <while_expression>
    ///    | <for_expression>
    ///    | <pipe_expression>
    ///    | <accesser>
    ///    | <literal>
    ///    | <function_call>
    ///    | <method_call>
    ///    | <field_access>
    ///    | "await" <expression>
    ///    | <tuple_or_grouped_expression>
    ///    | <struct_literal>
    ///    | <closer>
    ///    | <if_let_expression>
    ///    | <while_let_expression>
    ///    | <array_literal>
    ///    | <index_access>
    ///    | <cast_expression>
    /// ```
    fn parse_primary_expr(&mut self) -> Return<AST::PrimaryExpr<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <function_call> ::= "try"? <accesser> "(" <params> ")"
    /// ```
    fn parse_function_call(&mut self) -> Return<AST::FunctionCall<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <method_call> ::= "try"? <accesser> "." <IDENTIFIER> "(" <params> ")"
    /// ```
    fn parse_method_call(&mut self) -> Return<AST::MethodCall<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <field_access> ::= <accesser> "." <IDENTIFIER>
    /// ```
    fn parse_field_access(&mut self) -> Return<AST::FieldAccess<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <tuple_or_grouped_expression> ::= "(" <expression_list>? ")"
    /// ```
    fn parse_tuple_or_grouped_expression(&mut self) -> Return<AST::TupleOrGroupedExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_literal> ::= <accesser> "{" <struct_literal_fields>? "}"
    /// ```
    fn parse_struct_literal(&mut self) -> Return<AST::StructLiteral<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_literal_fields> ::= <struct_field_init<'_>> { "," <struct_field_init> }
    /// ```
    fn parse_struct_literal_fields(&mut self) -> Return<AST::StructLiteralFields<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_field_init> ::= ( <IDENTIFIER> ":" <expression> ) | <IDENTIFIER>
    /// ```
    fn parse_struct_field_init(&mut self) -> Return<AST::StructFieldInit<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <array_literal> ::= "[" <expression_list>? "]"
    /// ```
    fn parse_array_literal(&mut self) -> Return<AST::ArrayLiteral<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <index_access> ::= <expression> "[" <expression> "]"
    /// ```
    fn parse_index_access(&mut self) -> Return<AST::IndexAccess<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <cast_expression> ::= <expression> "as" <type_literal>
    /// ```
    fn parse_cast_expression(&mut self) -> Return<AST::CastExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <statement> ::=
    ///      <if_expression>
    ///    | <match_expression>
    ///    | <loop_expression>
    ///    | <while_expression>
    ///    | <for_statement>
    ///    | <expression_statement>
    ///    | <variable_declaration>
    ///    | "return" <expression> ";"
    ///    | "break" <expression> ";"
    ///    | "continue" ";"
    ///    | <assignment_statement>
    /// ```
    fn parse_statement(&mut self) -> Return<AST::Statement<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <expression_statement> ::= "ignore"? <expression> ";"
    /// ```
    fn parse_expression_statement(&mut self) -> Return<AST::ExpressionStatement<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <variable_declaration> ::= <variable_declaration_keyword> <pattern> ( ":" <type_literal> )? <variable_declaration_assignment>? ";"
    /// ```
    fn parse_variable_declaration(&mut self) -> Return<AST::VariableDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <variable_declaration_keyword> ::= "let" | "const"
    /// ```
    fn parse_variable_declaration_keyword(&mut self) -> Return<AST::VariableDeclarationKeyword<'_>> {
        unimplemented!();
    }

    #[rustfmt::skip]
    /// ```ebnf
    /// <variable_declaration_assignment> ::= <ASSIGNMENT_OPERATOR> <expression>
    /// ```
    fn parse_variable_declaration_assignment(&mut self) -> Return<AST::VariableDeclarationAssignment<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <assignment_statement> ::= <accesser> <ASSIGNMENT_OPERATOR> <expression> ";"
    /// ```
    fn parse_assignment_statement(&mut self) -> Return<AST::AssignmentStatement<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <field_declaration> ::= ( "final" | "mut" ) <IDENTIFIER> ":" <type_literal> ";"
    /// ```
    fn parse_field_declaration(&mut self) -> Return<AST::FieldDeclaration<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <param_with_type> ::= "mut"? ( <IDENTIFIER> ":" <type_literal> ( "=" <expression> )? ) | "this"
    /// ```
    fn parse_param_with_type(&mut self) -> Return<AST::ParamWithType<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <params_with_types> ::= <param_with_types_list>?
    /// ```
    fn parse_params_with_types(&mut self) -> Return<AST::ParamsWithTypes<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <param_with_types_list> ::= <param_with_type<'_>> { "," <param_with_type> }
    /// ```
    fn parse_param_with_types_list(&mut self) -> Return<AST::ParamWithTypesList<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <block_expression> ::= "{" { <statement> } | <expression> "}"
    /// ```
    fn parse_block_expression(&mut self) -> Return<AST::BlockExpression<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <is_public> ::= "pub" | "";
    /// ```
    fn parse_is_public(&mut self) -> Return<AST::IsPublic<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <literal> ::= <STRING_LITERAL> | <CHAR_LITERAL> | <NUM_LITERAL> | <BOOL_LITERAL>
    /// ```
    fn parse_literal(&mut self) -> Return<AST::Literal<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <type_literal> ::=
    ///      <accesser> <generic_type_args>?
    ///    | "impl" <type_literal>
    ///    | "typeof" <expression>
    ///    | "Bool"
    ///    | "Int"
    ///    | "DoubleInt"
    ///    | "Float"
    ///    | "DoubleFloat"
    ///    | "Char"
    ///    | "Usize"
    ///    | "Any"
    ///    | <tuple_type>
    ///    | "Never"
    ///    | "Void"
    /// ```
    fn parse_type_literal(&mut self) -> Return<AST::TypeLiteral<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <generic_type_args> ::= "<" <type_literal_list> ">"
    /// ```
    fn parse_generic_type_args(&mut self) -> Return<AST::GenericTypeArgs<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <tuple_type> ::= "(" <type_literal_list>? ")"
    /// ```
    fn parse_tuple_type(&mut self) -> Return<AST::TupleType<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <docs_comments> ::= { <DOCS_COMMENT> } { <annotation> }
    /// ```
    fn parse_docs_comments(&mut self) -> Return<AST::DocsComments<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <pattern> ::=
    ///      <IDENTIFIER>
    ///    | "_"
    ///    | <tuple_struct_pattern>
    ///    | <tuple_pattern>
    ///    | <struct_pattern>
    ///    | <accesser>
    ///    | <literal>
    ///    | <range_pattern>
    ///    | <binding_pattern>
    /// ```
    fn parse_pattern(&mut self) -> Return<AST::Pattern<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <tuple_struct_pattern> ::= <accesser> "(" <pattern_list>? ")"
    /// ```
    fn parse_tuple_struct_pattern(&mut self) -> Return<AST::TupleStructPattern<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <tuple_pattern> ::= "(" <pattern_list>? ")"
    /// ```
    fn parse_tuple_pattern(&mut self) -> Return<AST::TuplePattern<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_pattern> ::= <accesser> "{" <struct_pattern_fields>? "}"
    /// ```
    fn parse_struct_pattern(&mut self) -> Return<AST::StructPattern<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_pattern_fields> ::= <struct_pattern_field<'_>> { "," <struct_pattern_field> }
    /// ```
    fn parse_struct_pattern_fields(&mut self) -> Return<AST::StructPatternFields<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <struct_pattern_field> ::= ( <IDENTIFIER> ":" <pattern> ) | <IDENTIFIER>
    /// ```
    fn parse_struct_pattern_field(&mut self) -> Return<AST::StructPatternField<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <range_pattern> ::= ( <CHAR_LITERAL> | <NUM_LITERAL> ) <range_op> ( <CHAR_LITERAL> | <NUM_LITERAL> )
    /// ```
    fn parse_range_pattern(&mut self) -> Return<AST::RangePattern<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <range_op> ::= ".." | "..="
    /// ```
    fn parse_range_op(&mut self) -> Return<AST::RangeOp<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <binding_pattern> ::= <IDENTIFIER> "@" <pattern>
    /// ```
    fn parse_binding_pattern(&mut self) -> Return<AST::BindingPattern<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <generics> ::= "<" <generic_param_def_list> ">"
    /// ```
    fn parse_generics(&mut self) -> Return<AST::Generics<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <generic_param_def_list> ::= <generic_param_def<'_>> { "," <generic_param_def> }
    /// ```
    fn parse_generic_param_def_list(&mut self) -> Return<AST::GenericParamDefList<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <generic_param_def> ::= <IDENTIFIER> ( ":" <generic_bound> )?
    /// ```
    fn parse_generic_param_def(&mut self) -> Return<AST::GenericParamDef<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <generic_bound> ::= <type_literal<'_>> { "&" <type_literal> }
    /// ```
    fn parse_generic_bound(&mut self) -> Return<AST::GenericBound<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <implements_protocol> ::= ( ":" <accesser_list> )?
    /// ```
    fn parse_implements_protocol(&mut self) -> Return<AST::ImplementsProtocol<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <identifier_list> ::= <IDENTIFIER<'_>> { "," <IDENTIFIER> }
    /// ```
    fn parse_identifier_list(&mut self) -> Return<AST::IdentifierList<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <type_literal_list> ::= <type_literal<'_>> { "," <type_literal> }
    /// ```
    fn parse_type_literal_list(&mut self) -> Return<AST::TypeLiteralList<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <expression_list> ::= <expression<'_>> { "," <expression> }
    /// ```
    fn parse_expression_list(&mut self) -> Return<AST::ExpressionList<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <pattern_list> ::= <pattern<'_>> { "," <pattern> }
    /// ```
    fn parse_pattern_list(&mut self) -> Return<AST::PatternList<'_>> {
        unimplemented!();
    }

    /// ```ebnf
    /// <accesser_list> ::= <accesser<'_>> { "," <accesser> }
    /// ```
    fn parse_accesser_list(&mut self) -> Return<AST::AccesserList<'_>> {
        unimplemented!();
    }
}
