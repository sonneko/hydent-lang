// ==========================================
//  Generated by Script (see /script/index.ts)
//  DO NOT EDIT THIS FILE DIRECTLY
//  In "/src/parser/generated_parser.rs"
// ==========================================

use crate::compiler::arena::{Arena, ArenaBox, ArenaIter};
use crate::compiler::context::frontend::CompilerFrontendContext;
use crate::compiler::symbol::Symbol;
use crate::parser::errors::{IParseErr, ParseErr};
use crate::parser::parser::BaseParser;
use crate::tokenizer::tokens::{Delimiter, Keyword, Literal, Operator, Token};

#[allow(clippy::wildcard_imports)] // because of no knowledge of all ast types
use crate::parser::generated_ast::*;

#[allow(non_snake_case)]
pub trait GeneratedParser: BaseParser + Sized {
    #[inline]
    fn parse_Module(&mut self) -> Result<Module, Self::Error> {
        let declarations = self.repeat(|this: &mut Self| this.parse_TopLevelDeclaration());
        Ok(Module { declarations })
    }

    #[inline]
    fn parse_TopLevelDeclaration(&mut self) -> Result<TopLevelDeclaration, Self::Error> {
        match self.peek_n::<1>() {
            Some(Token::Keyword(Keyword::Fn)) => {
                Ok(TopLevelDeclaration::Function(self.parse_Function()?))
            }
            _ => Err(Self::Error::create(
                self.get_errors_arena(),
                [Token::Keyword(Keyword::Fn)],
                self.peek_n::<1>(),
            )),
        }
    }

    #[inline]
    fn parse_Function(&mut self) -> Result<Function, Self::Error> {
        self.expect_token(Token::Keyword(Keyword::Fn))?;
        let name = self.parse_Identifier()?;
        self.expect_token(Token::Delimiter(Delimiter::LeftParen))?;
        let params = self.repeat(|this: &mut Self| this.parse_Parameter());
        self.expect_token(Token::Delimiter(Delimiter::RightParen))?;
        let return_type = self.parse_TypeLiteral().ok();
        let body = self.parse_BlockExpression()?;
        Ok(Function {
            name,
            params,
            return_type,
            body,
        })
    }

    #[inline]
    fn parse_Parameter(&mut self) -> Result<Parameter, Self::Error> {
        let name = self.parse_Identifier()?;
        Ok(Parameter { name })
    }

    #[inline]
    fn parse_BlockExpression(&mut self) -> Result<BlockExpression, Self::Error> {
        self.expect_token(Token::Delimiter(Delimiter::LeftBrace))?;
        let statements = self.repeat(|this: &mut Self| this.parse_Statement());
        let final_expr = self.parse_Expression().ok();
        self.expect_token(Token::Delimiter(Delimiter::RightBrace))?;
        Ok(BlockExpression {
            statements,
            final_expr,
        })
    }

    #[inline]
    fn parse_Statement(&mut self) -> Result<Statement, Self::Error> {
        match self.peek_n::<1>() {
            Some(undefined) => Ok(Statement::ExpressionStmt(self.parse_ExpressionStmt()?)),
            Some(Token::Keyword(Keyword::Let)) => {
                Ok(Statement::Assignment(self.parse_Assignment()?))
            }
            Some(Token::Keyword(Keyword::Return)) => Ok(Statement::Return(self.parse_Return()?)),
            _ => Err(Self::Error::create(
                self.get_errors_arena(),
                [
                    Token::Keyword(Keyword::Let),
                    Token::Keyword(Keyword::Return),
                ],
                self.peek_n::<1>(),
            )),
        }
    }

    #[inline]
    fn parse_ExpressionStmt(&mut self) -> Result<ExpressionStmt, Self::Error> {
        let expr = self.parse_Expression()?;
        self.expect_token(Token::Delimiter(Delimiter::Semicolon))?;
        Ok(ExpressionStmt { expr })
    }

    #[inline]
    fn parse_Assignment(&mut self) -> Result<Assignment, Self::Error> {
        self.expect_token(Token::Keyword(Keyword::Let))?;
        let name = self.parse_Identifier()?;
        self.expect_token(Token::Operator(Operator::Assignment))?;
        let value = self.parse_Expression()?;
        self.expect_token(Token::Delimiter(Delimiter::Semicolon))?;
        Ok(Assignment { name, value })
    }

    #[inline]
    fn parse_Return(&mut self) -> Result<Return, Self::Error> {
        self.expect_token(Token::Keyword(Keyword::Return))?;
        let value = self.parse_Expression().ok();
        self.expect_token(Token::Delimiter(Delimiter::Semicolon))?;
        Ok(Return { value })
    }

    #[inline]
    fn parse_Expression(&mut self) -> Result<Expression, Self::Error> {
        todo!()
    }

    #[inline]
    fn parse_LiteralAST(&mut self) -> Result<LiteralAST, Self::Error> {
        let value = self.parse_StringLiteral()?;
        Ok(LiteralAST { value })
    }

    #[inline]
    fn parse_FunctionCall(&mut self) -> Result<FunctionCall, Self::Error> {
        let name = self.parse_Identifier()?;
        self.expect_token(Token::Delimiter(Delimiter::LeftParen))?;
        let args = self.repeat(|this: &mut Self| this.parse_Expression());
        self.expect_token(Token::Delimiter(Delimiter::RightParen))?;
        Ok(FunctionCall { name, args })
    }

    #[inline]
    fn parse_TypeLiteral(&mut self) -> Result<TypeLiteral, Self::Error> {
        match self.peek_n::<1>() {
            Some(Token::Keyword(Keyword::Int)) => Ok(TypeLiteral::IntType(self.parse_IntType()?)),
            _ => Err(Self::Error::create(
                self.get_errors_arena(),
                [Token::Keyword(Keyword::Int)],
                self.peek_n::<1>(),
            )),
        }
    }

    #[inline]
    fn parse_IntType(&mut self) -> Result<IntType, Self::Error> {
        self.expect_token(Token::Keyword(Keyword::Int))?;
        Ok(IntType {})
    }

    #[inline]
    fn parse_Identifier(&mut self) -> Result<Identifier, Self::Error>;

    #[inline]
    fn parse_StringLiteral(&mut self) -> Result<StringLiteral, Self::Error>;

    fn comma_separated_params(&mut self) -> Result<ArenaIter<Parameter>, Self::Error>;

    fn comma_separated_exprs(&mut self) -> Result<ArenaIter<Expression>, Self::Error>;
}
