// ==========================================
//  Generated by Script (see /script/index.ts)
//  DO NOT EDIT THIS FILE DIRECTLY
// ==========================================

use crate::compiler::arena::{ArenaBox, ArenaIter, Arena};
use crate::compiler::context::frontend::CompilerFrontendContext;
use crate::compiler::symbol::Symbol;
use crate::parser::errors::ParseErr;
use crate::parser::generated_ast::*;
use crate::parser::parser::BaseParser;
use crate::tokenizer::tokens::{Token, Literal, Keyword, Operator, Delimiter};


#[allow(non_snake_case)]
  pub trait GeneratedParser: BaseParser + Sized {
      // --- DI Hooks ---
      /// Hook for field 'params' in rule 'Function'
    fn comma_separated_params(&mut self) -> Result<ArenaIter<Parameter>, Self::Error>;

    /// Hook for field 'args' in rule 'FunctionCall'
    fn comma_separated_exprs(&mut self) -> Result<ArenaIter<Expression>, Self::Error>;
  
      // --- Error Recovery ---
      fn synchronize(&mut self) {
          unimplemented!()
      }
  
      // --- Parser Methods ---
  
      fn parse_Module(&mut self) -> Result<Module, Self::Error> {
  
          let declarations = 
          {
              let mut list = Vec::new();
              while let Some(token) = self.peek_token() {
                  if (*token == Token::Keyword(Keyword::Fn)) {
                      list.push(self.parse_TopLevelDeclaration()?);
                  } else {
                      break;
                  }
              }
              list
          };
          Ok(Module {
              declarations
          })
      
      }

      fn parse_TopLevelDeclaration(&mut self) -> Result<TopLevelDeclaration, Self::Error> {
  
          // Branch Selection based on First Sets
  
          if let Some(token) = self.peek_token() {
              if (*token == Token::Keyword(Keyword::Fn)) {
                  let val = self.parse_Function()?;
                  return Ok(TopLevelDeclaration::Function(val));
              }
          }
  
          Err(self.report_error(format!("Unexpected token for branch TopLevelDeclaration")))
      
      }

      fn parse_Function(&mut self) -> Result<Function, Self::Error> {
  
          self.expect_token("fn")?;
        let name = self.parse_Identifier()?;
        self.expect_token("(")?;
        let params = self.comma_separated_params()?;
        self.expect_token(")")?;
        let return_type = 
          if let Some(token) = self.peek_token() {
              if (*token == Token::Keyword(Keyword::Int)) {
                  Some(self.parse_TypeLiteral()?)
              } else {
                  None
              }
          } else {
              None
          };
        let body = self.parse_BlockExpression()?;
          Ok(Function {
              name,
            params,
            return_type,
            body
          })
      
      }

      fn parse_Parameter(&mut self) -> Result<Parameter, Self::Error> {
  
          let name = self.parse_Identifier()?;
          Ok(Parameter {
              name
          })
      
      }

      fn parse_BlockExpression(&mut self) -> Result<BlockExpression, Self::Error> {
  
          self.expect_token("{")?;
        let statements = 
          {
              let mut list = Vec::new();
              while let Some(token) = self.peek_token() {
                  if (*token == Token::Keyword(Keyword::Let) || *token == Token::Keyword(Keyword::Return) || *token == ERROR || *token == Token::Literal(Literal::StringLiteral($Span$)) || *token == ERROR || *token == Token::Identifier($Span$)) {
                      list.push(self.parse_Statement()?);
                  } else {
                      break;
                  }
              }
              list
          };
        let final_expr = 
          if let Some(token) = self.peek_token() {
              if (*token == ERROR || *token == Token::Literal(Literal::StringLiteral($Span$)) || *token == ERROR || *token == Token::Identifier($Span$)) {
                  Some(self.parse_Expression()?)
              } else {
                  None
              }
          } else {
              None
          };
        self.expect_token("}")?;
          Ok(BlockExpression {
              statements,
            final_expr
          })
      
      }

      fn parse_Statement(&mut self) -> Result<Statement, Self::Error> {
  
          // Branch Selection based on First Sets
  
          if let Some(token) = self.peek_token() {
              if (*token == ERROR || *token == Token::Literal(Literal::StringLiteral($Span$)) || *token == ERROR || *token == Token::Identifier($Span$)) {
                  let val = self.parse_ExpressionStmt()?;
                  return Ok(Statement::ExpressionStmt(val));
              }
          }
          if let Some(token) = self.peek_token() {
              if (*token == Token::Keyword(Keyword::Let)) {
                  let val = self.parse_Assignment()?;
                  return Ok(Statement::Assignment(val));
              }
          }
          if let Some(token) = self.peek_token() {
              if (*token == Token::Keyword(Keyword::Return)) {
                  let val = self.parse_Return()?;
                  return Ok(Statement::Return(val));
              }
          }
  
          Err(self.report_error(format!("Unexpected token for branch Statement")))
      
      }

      fn parse_ExpressionStmt(&mut self) -> Result<ExpressionStmt, Self::Error> {
  
          let expr = self.parse_Expression()?;
        self.expect_token(";")?;
          Ok(ExpressionStmt {
              expr
          })
      
      }

      fn parse_Assignment(&mut self) -> Result<Assignment, Self::Error> {
  
          self.expect_token("let")?;
        let name = self.parse_Identifier()?;
        self.expect_token("=")?;
        let value = self.parse_Expression()?;
        self.expect_token(";")?;
          Ok(Assignment {
              name,
            value
          })
      
      }

      fn parse_Return(&mut self) -> Result<Return, Self::Error> {
  
          self.expect_token("return")?;
        let value = 
          if let Some(token) = self.peek_token() {
              if (*token == ERROR || *token == Token::Literal(Literal::StringLiteral($Span$)) || *token == ERROR || *token == Token::Identifier($Span$)) {
                  Some(self.parse_Expression()?)
              } else {
                  None
              }
          } else {
              None
          };
        self.expect_token(";")?;
          Ok(Return {
              value
          })
      
      }

      fn parse_Expression(&mut self) -> Result<Expression, Self::Error> {
  
          // Branch Selection based on First Sets
  
          if let Some(token) = self.peek_token() {
              if (*token == ERROR || *token == Token::Literal(Literal::StringLiteral($Span$))) {
                  let val = self.parse_Literal()?;
                  return Ok(Expression::Literal(val));
              }
          }
          if let Some(token) = self.peek_token() {
              if (*token == ERROR || *token == Token::Identifier($Span$)) {
                  let val = self.parse_FunctionCall()?;
                  return Ok(Expression::FunctionCall(val));
              }
          }
  
          Err(self.report_error(format!("Unexpected token for branch Expression")))
      
      }

      fn parse_Literal(&mut self) -> Result<Literal, Self::Error> {
  
          let value = self.parse_StringLiteral()?;
          Ok(Literal {
              value
          })
      
      }

      fn parse_FunctionCall(&mut self) -> Result<FunctionCall, Self::Error> {
  
          let name = self.parse_Identifier()?;
        self.expect_token("(")?;
        let args = self.comma_separated_exprs()?;
        self.expect_token(")")?;
          Ok(FunctionCall {
              name,
            args
          })
      
      }

      fn parse_TypeLiteral(&mut self) -> Result<TypeLiteral, Self::Error> {
  
          // Branch Selection based on First Sets
  
          if let Some(token) = self.peek_token() {
              if (*token == Token::Keyword(Keyword::Int)) {
                  let val = self.parse_IntType()?;
                  return Ok(TypeLiteral::IntType(val));
              }
          }
  
          Err(self.report_error(format!("Unexpected token for branch TypeLiteral")))
      
      }

      fn parse_IntType(&mut self) -> Result<IntType, Self::Error> {
  
          self.expect_token("Int")?;
          Ok(IntType {
              
          })
      
      }

      fn parse_Identifier(&mut self) -> Result<Identifier, Self::Error> {
  
          self.expect_token("#identifier")?;
          Ok(Identifier {
              
          })
      
      }

      fn parse_StringLiteral(&mut self) -> Result<StringLiteral, Self::Error> {
  
          self.expect_token("#string")?;
          Ok(StringLiteral {
              
          })
      
      }
  }
   