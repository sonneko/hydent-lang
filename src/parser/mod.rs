use crate::compiler::{
    arena::Arena, context::frontend::CompilerFrontendContext,
    source_holder::SourceHolder, symbol::SymbolFactory,
};
use crate::diagnostic::CompilerDiagnostic;
use crate::parser::{errors::ParseErr, parse::Parser};
use crate::tokenizer::errors::TokenizeErr;
use crate::tokenizer::token_stream::TokenStream;
use crate::tokenizer::tokenize::Tokenizer;
use crate::compiler::runtime::{Engine, Query};


#[cfg(test)]
mod tests;

mod ast_node;
mod base_parser;
mod errors;
mod generated_ast; // generated by script
mod generated_ast_printer;
mod generated_parser; // generated by script
mod manual_ast;
mod manual_parser;
mod parse;

pub mod ast {
    pub use crate::parser::generated_ast::*;
}

pub struct ParseResult {
    pub ast: generated_ast::Module,
    pub diagnostics: Vec<Box<dyn CompilerDiagnostic>>,
}

pub struct ParseFileQuery;
impl Query for ParseFileQuery {
    type From = String;
    type To = ();
    fn run<E: Engine>(
        engine: &E,
        src: Self::From,
    ) -> Self::To {
        let source_holder = SourceHolder::new(&src);
        let ast_arena = Arena::new();
        let errors_arena = Arena::new();
        let mut ctx = CompilerFrontendContext {
            source: source_holder,
            symbol_factory: SymbolFactory::new(source_holder),
            ast_arena: &ast_arena,
            errors_arena: &ast_arena,
        };

        let tokens = {
            let tokenizer = Tokenizer::new(&src, &mut ctx.symbol_factory);
            let (tokens, _) = tokenizer.tokenize();
            tokens
        };

        let parser = Parser::new(TokenStream::new(tokens), ctx);
        let ast = parser
            .parse()
            .map_err(<ParseErr as Into<Box<dyn CompilerDiagnostic>>>::into);

        // TODO: construct parse result and return

        todo!()
    }
}
