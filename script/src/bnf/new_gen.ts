import { BranchParserFunction, ProductParserFunction, HookParserFunction, IR } from "./new_ir";

class Generator {
    public generateParser(ir: IR): string {
        const funcs = [];
        for (const func of ir) {
            switch (func.kind) {
                case "branch":
                    funcs.push(this.generateBranchParseFunction(func));
                    break;
                case "product":
                    funcs.push(this.generateProductParserFunction(func));
                    break;
                case "hook":
                    funcs.push(this.generateHookParserFunction(func));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_parser.rs"\n`;
        ret += `// ==========================================\n`;
        ret += `\n`;
        ret += `#![allow(clippy::all)]\n`;
        ret += `\n`;
        ret += `use crate::compiler::arena::{Arena, ArenaBox, ArenaIter};\n`;
        ret += `use crate::compiler::context::frontend::CompilerFrontendContext;\n`;
        ret += `use crate::compiler::symbol::Symbol;\n`;
        ret += `use crate::parser::base_parser::BaseParser;\n`;
        ret += `use crate::parser::errors::{IParseErr, ParseErr};\n`;
        ret += `use crate::tokenizer::tokens::{Delimiter, Keyword, Literal, Operator, Token};\n`;
        ret += `\n`;
        ret += `#[allow(clippy::wildcard_imports)] // because of no knowledge of all ast types\n`;
        ret += `use crate::parser::generated_ast::*;\n`;
        ret += `\n`;
        ret += `#[allow(non_snake_case)]\n`;
        ret += `\n`;
        ret += `pub trait GeneratedParser: BaseParser + Sized {`;
        ret += funcs.join("");
        ret += `}`;
        return ret;
    }

    private generateBranchParseFunction(func: BranchParserFunction): string {
        let ret = "";
        // 1 indent
        ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {`;
        // 2 indent
        ret += `match self.peek::<0>() {`;
        // 3 indent
        for (const branch of func.branchesJudgebleInPeek0) {
            ret += `Some(${branch.firstTerminal}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),`;
        }
        if (func.branchesJudgebleInPeek1.length === 0 && func.branchesNeedBacktrack.length === 0) {
            // TODO: add infomation for error messaging as params of Error::build static method
            ret += `_ => Self::Error::build(self.get_errors_arena(), &[], self.peek::<0>()),`;
        }
        if (func.branchesJudgebleInPeek1.length !== 0 && func.branchesNeedBacktrack.length === 0) {
            ret += `_ => match (self.peek::<0>(), self.peek::<1>()) {`;
            // 4 indent
            for (const branch of func.branchesJudgebleInPeek1) {
                ret += `(Some(${branch.firstTerminal}), Some(${branch.secondTerminal})) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),`;
            }
            ret += `}`;
            // 3 indent
        }
        if (func.branchesNeedBacktrack.length !== 0 && func.branchesJudgebleInPeek1.length === 0) {
            ret += `_ => `;
            ret += `backtrack![`;
            // 4 indent
            for (const branch of func.branchesNeedBacktrack) {
                ret += `Self::parse_${branch.astTypeName},`;
            }
            ret += `],`;
            // 3 indent
        }
        if (func.branchesJudgebleInPeek1.length !== 0 && func.branchesNeedBacktrack.length !== 0) {
            ret += `_ => match (self.peek::<0>(), self.peek::<1>()) {`;
            // 4 indent
            for (const branch of func.branchesJudgebleInPeek1) {
                ret += `(Some(${branch.firstTerminal}), Some(${branch.secondTerminal})) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),`;
            }
            ret += `_ => `;
            ret += `backtrack![`;
            // 5 indent
            for (const branch of func.branchesNeedBacktrack) {
                ret += `Self::parse_${branch.astTypeName},`;
            }
            ret += `],`;
            // 4 indent
            ret += `}`;
            // 3 indent
        }
        ret += `},`;
        // 2 indent
        ret += `}`;
        // 1 indent
        return ret;
    }

    private generateProductParserFunction(func: ProductParserFunction): string {
        let ret = "";
        ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `let ${element.astTypeName} = self.parse_${element.astTypeName}()?;`;
                    break;
                case "boxed":
                    ret += `let ${element.astTypeName} = self.alloc(self.parse_${element.astTypeName}()?);`;
                    break;
                case "option":
                    ret += `let ${element.astTypeName} = self.parse_${element.astTypeName}().ok();`;
                    break;
                case "repeat":
                    ret += `let ${element.astTypeName} = self.repeat(Self::parse_${element.astTypeName});`;
                    break;
            }
        }
        ret += `Ok(${func.astTypeName} {`;
        for (const element of func.elements) {
            ret += `${element.astTypeName},`;
        }
        ret += `})`;
        ret += `}`;
        return ret;
    }

    private generateHookParserFunction(func: HookParserFunction): string {
        let ret = "";
        ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;`;
        return ret;
    }

    public generateASTType(ir: IR): string {
        let decls = [];
        for (const element of ir) {
            switch (element.kind) {
                case "branch":
                    decls.push(this.generateBranchASTType(element));
                    break;
                case "product":
                    decls.push(this.generateProductASTType(element));
                    break;
                case "hook":
                    decls.push(this.generateHookASTType(element));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_ast.rs"\n`;
        ret += `// ==========================================\n\n\n`;
        ret += `#![allow(clippy::all)]\n`;
        ret += `\n`;
        ret += `use crate::compiler::arena::{ArenaBox, ArenaIter};\n`;
        ret += `use crate::parser::ast::ASTNode;\n`;
        ret += `use crate::parser::ast::SyncPointBitMap;\n`;
        ret += `use crate::parser::errors::ParseErr;\n`;
        ret += `use crate::tokenizer::tokens::Token;\n`;
        ret += `\n`;
        ret += decls.join("");
        return ret;
    }

    private generateBranchASTType(func: BranchParserFunction): string {
        let ret = "";
        ret += `pub enum ${func.astTypeName} {`;
        for (const branch of [...func.branchesJudgebleInPeek0, ...func.branchesJudgebleInPeek1, ...func.branchesNeedBacktrack]) {
            ret += `${branch.astTypeName}(${branch.astTypeName}),`;
        }
        ret += `}`;
        return ret;
    }

    private generateProductASTType(func: ProductParserFunction): string {
        let ret = "";
        // TODO: add sync points information for parse recocery
        ret += `impl ASTNode for ${func.astTypeName} {`
        ret += `const SYNC_POINT_SETS: SyncPointBitMap = SyncPointBitMap::build_map(&[], false, false, false);`;
        ret += `fn get_error_situation(err: ParseErr) -> Option<Self> {`;
        ret += `None`;
        ret += `}`;
        ret += `}`;
        ret += `pub struct ${func.astTypeName} {`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `${element.astTypeName}: ${element.astTypeName},`;
                    break;
                case "boxed":
                    ret += `${element.astTypeName}: ArenaBox<${element.astTypeName}>,`;
                    break;
                case "option":
                    ret += `${element.astTypeName}: Option<${element.astTypeName}>,`;
                    break;
                case "repeat":
                    ret += `${element.astTypeName}: ArenaIter<${element.astTypeName}>,`;
                    break;
            }
        }
        ret += `}`;
        return ret;
    }

    private generateHookASTType(func: HookParserFunction): string {
        return `use crate::parser::manual_parser::${func.astTypeName};`;
    }
}

export function generate(ir: IR): [string, string] {
    const gen = new Generator();
    return [
        gen.generateParser(ir),
        gen.generateASTType(ir)
    ]
}