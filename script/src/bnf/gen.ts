import { readFileSync } from 'node:fs';
import {
    GrammarIR, RuleIR, ElementIR,
    ProductRuleIR, BranchRuleIR,
    HookIR
} from './analyzer';


const TYPE_DEFINITION_PREFIX = `\
// ==========================================
//  Generated by Script (see /script/index.ts)
//  DO NOT EDIT THIS FILE DIRECTLY
//  In "/src/parser/generated_ast.rs"
// ==========================================

use crate::compiler::arena::{ArenaIter, ArenaBox};

`;

const PARSER_PREFIX = `\
// ==========================================
//  Generated by Script (see /script/index.ts)
//  DO NOT EDIT THIS FILE DIRECTLY
//  In "/src/parser/generated_parser.rs"
// ==========================================

use crate::compiler::arena::{ArenaBox, ArenaIter, Arena};
use crate::compiler::context::frontend::CompilerFrontendContext;
use crate::compiler::symbol::Symbol;
use crate::parser::errors::ParseErr;
use crate::parser::generated_ast::*;
use crate::parser::parser::BaseParser;
use crate::tokenizer::tokens::{Token, Literal, Keyword, Operator, Delimiter};

`;

// Convert concrete syntax to Rust token type
// example: "Int" => "Token::Keyword(Keyword::Int)"
const TOKENS_MAP = ((): Map<string, string> => {
    const csv = readFileSync(`${process.cwd()}/../assets/token_map.csv`, "utf8").toString();
    let map: Map<string, string> = new Map();
    csv.split("\n").forEach(line => {
        const literals = line.split("\"");
        map.set(literals[1], literals[3]);
    });
    return map;
})();


export class RustParserGenerator {
    private ir: GrammarIR;

    constructor(ir: GrammarIR) {
        this.ir = ir;
    }

    public generate(): [string, string] {
        const typeDefs = this.generateTypeDefs();
        const traitDef = this.generateParserTrait();

        return [`${TYPE_DEFINITION_PREFIX}${typeDefs}`, `${PARSER_PREFIX}${traitDef}`];
    }

    // -------------------------------------------------------------------------
    // 1. Type definition (Structs & Enums)
    // -------------------------------------------------------------------------

    private generateTypeDefs(): string {
        const code: string[] = [];

        for (const [_, rule] of this.ir.rules) {
            if (rule.kind === 'Branch') {
                // Branch
                const variants = rule.variants
                    .map(v => `    ${v.rustVariantName}(${v.targetRule}),`)
                    .join('\n');

                code.push(`
#[derive(Debug, Copy, Clone, std::hash::Hash, PartialEq, Eq)]
pub enum ${rule.rustName} {
${variants}
}`);
            } else {
                // Product
                const fields = rule.elements
                    .filter((e): e is Extract<ElementIR, { kind: 'NonTerminal' }> => e.kind === 'NonTerminal')
                    .map(e => {
                        let typeStr = this.getRustType(e.targetRule, e.modifier);
                        if (e.isBoxed) {
                            typeStr = `ArenaBox<${typeStr}>`;
                        }
                        return `    pub ${e.rustFieldName}: ${typeStr},`;
                    })
                    .join('\n');

                code.push(`
#[derive(Debug, Copy, Clone, std::hash::Hash, PartialEq, Eq)]
pub struct ${rule.rustName} {
${fields}
}`);
            }
        }
        return code.join('\n');
    }

    // -------------------------------------------------------------------------
    // 2. Parser Trait & Logic
    // -------------------------------------------------------------------------

    private generateParserTrait(): string {
        const methods: string[] = [];

        // methods with default implementations
        for (const [_, rule] of this.ir.rules) {
            switch (rule.kind) {
                case "Branch":
                    methods.push(this.generateBranchMethod(rule));
                    break;
                case "Product":
                    methods.push(this.generateProductMethod(rule));
                    break;
            }
        }

        // methods without default implementations
        for (const [_, rule] of this.ir.hooks) {
            methods.push(this.generateHookMethod(rule));
        }

        return `\
pub trait GeneratedParser: BaseParser + Sized {
${methods.join('\n')}
}

`;
    }

    // -------------------------------------------------------------------------
    // Method generator
    // -------------------------------------------------------------------------

    private generateBranchMethod(rule: BranchRuleIR): string {
        // TODO: implement this
        
        // A. Try parsing one peek (L1 grammar)

        // B. Only if A failed, start LL(k) grammar analysis
        
    }

    private generateProductMethod(rule: ProductRuleIR): string {
        const functionCalls: string[] = [];
        for (const [_, element] of rule.elements.entries()) {
            // TODO: implement hook calling logic
            switch (element.kind) {
                case "NonTerminal":
                    const ruleName = element.targetRule;
                    let typeStr = this.getRustType(ruleName, element.modifier);
                    if (element.isBoxed) {
                        typeStr = `ArenaBox<${typeStr}>`;
                    }
                    functionCalls.push(`\
        let ${element.rustFieldName} = self.parse_${ruleName}()?;`);
                    break;
                case "Terminal":
                    const tokenType = TOKENS_MAP.get(element.value);
                    if (tokenType === undefined) {
                        throw new Error(`Unknown token type: ${element.value}`);
                    }
                    functionCalls.push(`\
        self.expect_token("${tokenType}")?;`);
                    break;
            }
        }
        return `\
    fn parse_${rule.rustName}(&mut self) -> Result<${rule.rustName}, Self::Error> {
${functionCalls.join('\n')}
    }`;
    }

    private generateHookMethod(rule: HookIR): string {
        // TODO: implement hook definition
    }

    // -------------------------------------------------------------------------
    // Helpers
    // -------------------------------------------------------------------------

    private getRustType(ruleName: string, modifier: 'None' | 'List' | 'Option'): string {
        switch (modifier) {
            case 'List': return `ArenaIter<${ruleName}>`;
            case 'Option': return `Option<${ruleName}>`;
            case 'None': return ruleName;
        }
    }
}

export function generateParser(ir: GrammarIR): [string, string] {
    const generator = new RustParserGenerator(ir);
    return generator.generate();
}
