import { BranchParserFunction, ProductParserFunction, HookParserFunction, IR, tokenName } from "./ir";

class Generator {
    public generateParser(ir: IR): string {
        const funcs = [];
        for (const func of ir) {
            switch (func.kind) {
                case "branch":
                    funcs.push(this.generateBranchParseFunction(func));
                    break;
                case "product":
                    funcs.push(this.generateProductParserFunction(func));
                    break;
                case "hook":
                    funcs.push(this.generateHookParserFunction(func));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_parser.rs"\n`;
        ret += `// ==========================================\n`;
        ret += `\n`;
        ret += `\n`;
        ret += `use crate::compiler::arena::{Arena, ArenaBox, ArenaIter};\n`;
        ret += `use crate::compiler::context::frontend::CompilerFrontendContext;\n`;
        ret += `use crate::compiler::symbol::Symbol;\n`;
        ret += `use crate::parser::base_parser::BaseParser;\n`;
        ret += `use crate::parser::errors::{IParseErr, ParseErr};\n`;
        ret += `use crate::tokenizer::tokens::{Delimiter, Keyword, Literal, Operator, Token};\n`;
        ret += `\n`;
        ret += `#[allow(clippy::wildcard_imports)] // because of no knowledge of all ast types\n`;
        ret += `use crate::parser::generated_ast::*;\n`;
        ret += `\n`;
        ret += `#[allow(non_snake_case)]\n`;
        ret += `pub trait GeneratedParser: BaseParser + Sized {`;
        ret += funcs.join("");
        ret += `}`;
        return ret;
    }

    private generateBranchParseFunction(func: BranchParserFunction): string {
        let ret = "";
        // 1 indent
        ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {`;
        // 2 indent
        ret += `match self.peek::<0>() {`;
        // 3 indent
        for (const branch of func.branchesJudgebleInPeek0) {
            ret += `Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),`;
        }
        if (func.branchesJudgebleInPeek1.length === 0 && func.branchesNeedBacktrack.length === 0) {
            ret += `_ => Err(Self::Error::build(`;
            ret += `self.get_errors_arena(),`;
            ret += func.expectedTerminals.some(t => t.includes("$")) ? "true," : "false,";
            ret += `[${func.expectedTerminals.filter(t => !t.includes("$"))}],`;
            ret += `self.enviroment(),`;
            ret += `)),`
        }
        if (func.branchesJudgebleInPeek1.length !== 0 && func.branchesNeedBacktrack.length === 0) {
            ret += `_ => match (self.peek::<0>(), self.peek::<1>()) {`;
            // 4 indent
            for (const branch of func.branchesJudgebleInPeek1) {
                ret += `(Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}), Some(${branch.secondTerminal.replace(/\$.*\$/, "_")})) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),`;
            }
            ret += `}`;
            // 3 indent
        }
        if (func.branchesNeedBacktrack.length !== 0 && func.branchesJudgebleInPeek1.length === 0) {
            ret += `_ => `;
            ret += `backtrack![`;
            // 4 indent
            for (const branch of func.branchesNeedBacktrack) {
                ret += `Self::parse_${branch.astTypeName},`;
            }
            ret += `],`;
            // 3 indent
        }
        if (func.branchesJudgebleInPeek1.length !== 0 && func.branchesNeedBacktrack.length !== 0) {
            ret += `_ => match (self.peek::<0>(), self.peek::<1>()) {`;
            // 4 indent
            for (const branch of func.branchesJudgebleInPeek1) {
                ret += `(Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}), Some(${branch.secondTerminal.replace(/\$.*\$/, "_")})) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),`;
            }
            ret += `_ => `;
            ret += `backtrack![`;
            // 5 indent
            for (const branch of func.branchesNeedBacktrack) {
                ret += `Self::parse_${branch.astTypeName},`;
            }
            ret += `],`;
            // 4 indent
            ret += `}`;
            // 3 indent
        }
        ret += `}`;
        // 2 indent
        ret += `}`;
        // 1 indent
        return ret;
    }

    private generateProductParserFunction(func: ProductParserFunction): string {
        let ret = "";
        let isManual = func.elements.filter(element => element.kind === "terminal").some(element => element.tokenTypeName.includes("$"));
        if (isManual) {
            ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;`
            return ret;
        }
        ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `let ${element.astTypeName} = self.parse_${element.astTypeName}()?;`;
                    break;
                case "boxed":
                    ret += `let ${element.astTypeName} = self.alloc(self.parse_${element.astTypeName}()?);`;
                    break;
                case "option":
                    ret += `let ${element.astTypeName} = self.parse_${element.astTypeName}().ok();`;
                    break;
                case "repeat":
                    ret += `let ${element.astTypeName} = self.repeat(Self::parse_${element.astTypeName});`;
                    break;
                case "terminal":
                    if (element.tokenTypeName.includes("$")) {
                        break;
                    }
                    ret += `self.expect(${element.tokenTypeName})?;`;
                    break;
            }
        }
        ret += `Ok(${func.astTypeName} {`;
        for (const element of func.elements) {
            if (element.kind === "terminal") {
                continue;
            }
            ret += `${element.astTypeName},`;
        }
        ret += `})`;
        ret += `}`;
        return ret;
    }

    private generateHookParserFunction(func: HookParserFunction): string {
        let ret = "";
        ret += `fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;`;
        return ret;
    }

    public generateASTType(ir: IR): string {
        let decls = [];
        for (const element of ir) {
            switch (element.kind) {
                case "branch":
                    decls.push(this.generateBranchASTType(element));
                    break;
                case "product":
                    decls.push(this.generateProductASTType(element));
                    break;
                case "hook":
                    decls.push(this.generateHookASTType(element));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_ast.rs"\n`;
        ret += `// ==========================================\n\n\n`;
        ret += `#![allow(non_snake_case)]\n`;
        ret += `#![allow(nonstandard_style)]`
        ret += `\n`;
        ret += `use crate::compiler::arena::{ArenaBox, ArenaIter};\n`;
        ret += `use crate::parser::ast::ASTNode;\n`;
        ret += `use crate::parser::ast::SyncPointBitMap;\n`;
        ret += `use crate::parser::errors::ParseErr;\n`;
        ret += `use crate::tokenizer::tokens::{Token, Delimiter, Keyword, Operator};\n`;
        ret += `\n`;
        ret += decls.join("");
        return ret;
    }

    private generateBranchASTType(func: BranchParserFunction): string {
        let ret = "";
        ret += `impl ASTNode for ${func.astTypeName} {`
        ret += `const SYNC_POINT_SETS: SyncPointBitMap = SyncPointBitMap::build_map(${func.syncPointsTerminals.some(t => t.includes("Identifier")) ? "true" : "false"}, &[${func.syncPointsTerminals.filter(t => !t.includes("$")).join(",")}]);`;
        ret += `fn get_error_situation(err: ParseErr) -> Option<Self> {`;
        ret += `Some(Self::Invalid)`;
        ret += `}`;
        ret += `}`;
        ret += `#[derive(Copy, Clone, Debug, std::hash::Hash, PartialEq, Eq)]`
        ret += `pub enum ${func.astTypeName} {`;
        let dublicateRemoved = new Set([...func.branchesJudgebleInPeek0, ...func.branchesJudgebleInPeek1, ...func.branchesNeedBacktrack].map(branch => branch.astTypeName));
        for (const typeName of dublicateRemoved) {
            ret += `${typeName}(${typeName}),`;
        }
        ret += `Invalid,`
        ret += `}`;
        return ret;
    }

    private generateProductASTType(func: ProductParserFunction): string {
        let ret = "";
        let isManual = func.elements.filter(element => element.kind === "terminal").some(element => element.tokenTypeName.includes("$"));
        if (isManual) {
            ret += `pub use crate::parser::manual_ast::${func.astTypeName};`
            return ret;
        }
        ret += `impl ASTNode for ${func.astTypeName} {`
        ret += `const SYNC_POINT_SETS: SyncPointBitMap = SyncPointBitMap::build_map(${func.syncPointsTerminals.some(t => t.includes("Identifier")) ? "true" : "false"}, &[${func.syncPointsTerminals.filter(t => !t.includes("$")).join(",")}]);`;
        ret += `fn get_error_situation(err: ParseErr) -> Option<Self> {`;
        ret += `None`;
        ret += `}`;
        ret += `}`;
        ret += `#[derive(Copy, Clone, Debug, std::hash::Hash, PartialEq, Eq)]`;
        ret += `pub struct ${func.astTypeName} {`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `pub ${element.astTypeName}: ${element.astTypeName},`;
                    break;
                case "boxed":
                    ret += `pub ${element.astTypeName}: ArenaBox<${element.astTypeName}>,`;
                    break;
                case "option":
                    ret += `pub ${element.astTypeName}: Option<${element.astTypeName}>,`;
                    break;
                case "repeat":
                    ret += `pub ${element.astTypeName}: ArenaIter<${element.astTypeName}>,`;
                    break;
            }
        }
        ret += `}`;
        return ret;
    }

    private generateHookASTType(func: HookParserFunction): string {
        return `use crate::parser::manual_ast::${func.astTypeName};`;
    }
}

export function generate(ir: IR): [string, string] {
    const gen = new Generator();
    return [
        gen.generateParser(ir),
        gen.generateASTType(ir)
    ]
}