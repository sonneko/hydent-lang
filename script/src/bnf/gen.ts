import { BranchParserFunction, ProductParserFunction, HookParserFunction, IR } from "./ir";

class Generator {
    public generateParser(ir: IR): string {
        const funcs = [];
        for (const func of ir) {
            switch (func.kind) {
                case "branch":
                    funcs.push(this.generateBranchParseFunction(func));
                    break;
                case "product":
                    funcs.push(this.generateProductParserFunction(func));
                    break;
                case "hook":
                    funcs.push(this.generateHookParserFunction(func));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_parser.rs"\n`;
        ret += `// ==========================================\n\n`;
        ret += `use crate::compiler::arena::{Arena, ArenaBox, ArenaIter};\n`;
        ret += `use crate::compiler::context::frontend::CompilerFrontendContext;\n`;
        ret += `use crate::compiler::symbol::Symbol;\n`;
        ret += `use crate::parser::base_parser::BaseParser;\n`;
        ret += `use crate::parser::errors::{IParseErr, ParseErr};\n`;
        ret += `use crate::tokenizer::tokens::{Delimiter, Keyword, Literal, Operator, Comment, Token};\n\n`;
        ret += `#[allow(clippy::wildcard_imports)]\n`;
        ret += `use crate::parser::generated_ast::*;\n\n`;
        ret += `#[allow(non_snake_case)]\n`;
        ret += `pub trait GeneratedParser: BaseParser + Sized {`;
        ret += funcs.join("");
        ret += `}`;
        return ret;
    }

    private generateBranchParseFunction(func: BranchParserFunction): string {
        let ret = "";
        ret += `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {\n`;

        // Handle empty branches (edge case)
        if (func.branchesJudgebleInPeek0.length === 0 &&
            func.branchesJudgebleInPeek1.length === 0 &&
            (func.branchesFallbackInPeek1 || []).length === 0 &&
            func.branchesNeedBacktrack.length === 0) {
            ret += `        Err(Self::Error::build(self.get_errors_arena(), false, [], self.enviroment()))\n`;
            ret += `    }\n`;
            return ret;
        }

        ret += `        match self.peek::<0>() {\n`;

        // 1. Simple Peek<0> matches
        for (const branch of func.branchesJudgebleInPeek0.sort()) {
            if (branch.isBoxed) {
                ret += `            Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.alloc_box(|this| this.parse_${branch.astTypeName}())?)),\n`;
            } else {
                ret += `            Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),\n`;
            }
        }

        // 2. Complex matches (Peek<1> required or Backtrack required)
        const complexFirstTerminals = [...new Set([
            ...func.branchesJudgebleInPeek1.map(b => b.firstTerminal),
            ...func.branchesNeedBacktrack.map(b => b.firstTerminal),
            ...(func.branchesFallbackInPeek1 || []).map(b => b.firstTerminal)
        ])];

        for (const t0 of complexFirstTerminals.sort()) {
            ret += `            Some(${t0.replace(/\$.*\$/, "_")}) => {\n`;
            ret += `                match self.peek::<1>() {\n`;

            const peek1 = func.branchesJudgebleInPeek1.filter(b => b.firstTerminal === t0);
            for (const branch of peek1.sort()) {
                if (branch.isBoxed) {
                    ret += `                    Some(${branch.secondTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.alloc_box(|this| this.parse_${branch.astTypeName}())?)),\n`;
                } else {
                    ret += `                    Some(${branch.secondTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),\n`;
                }
            }

            const backtrack = func.branchesNeedBacktrack.filter(b => b.firstTerminal === t0);
            if (backtrack.length > 0) {
                ret += `                    _ => {\n`;
                ret += `                        // Backtrack required for multi-sequence collision\n`;
                ret += `                        unimplemented!("backtrack needed for ${t0}");\n`;
                ret += `                    }\n`;
            } else {
                const fallback = (func.branchesFallbackInPeek1 || []).find(b => b.firstTerminal === t0);
                if (fallback) {
                    if (fallback.isBoxed) {
                        ret += `                    _ => Ok(${func.astTypeName}::${fallback.astTypeName}(self.alloc_box(|this| this.parse_${fallback.astTypeName}())?),\n`;
                    } else {
                        ret += `                    _ => Ok(${func.astTypeName}::${fallback.astTypeName}(self.parse_${fallback.astTypeName}()?)),\n`;
                    }
                } else {
                    ret += `                    _ => Err(Self::Error::build(self.get_errors_arena(), false, [], self.enviroment())),\n`;
                }
            }

            ret += `                }\n`;
            ret += `            },\n`;
        }

        // 3. Error Case
        ret += `            _ => Err(Self::Error::build(\n`;
        ret += `                self.get_errors_arena(),\n`;
        ret += `                ${func.expectedTerminals.some(t => t.includes("$")) ? "true" : "false"},\n`;
        const expected = [...new Set(func.expectedTerminals.filter(t => !t.includes("$") && !t.includes("_")))];
        ret += `                [${expected.join(", ")}],\n`;
        ret += `                self.enviroment(),\n`;
        ret += `            )),\n`;

        ret += `        }\n`;
        ret += `    }\n`;
        return ret;
    }

    private generateProductParserFunction(func: ProductParserFunction): string {
        let ret = "";
        let isManual = func.elements.some(element => element.kind === "terminal" && element.tokenTypeName.includes("$"));
        if (isManual) {
            ret += `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;\n`;
            return ret;
        }
        ret += `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {\n`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `        let ${element.astTypeName} = self.parse_${element.astTypeName}()?;\n`;
                    break;
                case "boxed":
                    ret += `        let ${element.astTypeName} = self.alloc_box(|this| this.parse_${element.astTypeName}())?;\n`;
                    break;
                case "option":
                    ret += `        let ${element.astTypeName} = self.parse_${element.astTypeName}().ok();\n`;
                    break;
                case "repeat":
                    ret += `        let ${element.astTypeName} = self.repeat(Self::parse_${element.astTypeName});\n`;
                    break;
                case "terminal":
                    if (!element.tokenTypeName.includes("$")) {
                        ret += `        self.expect(${element.tokenTypeName})?;\n`;
                    }
                    break;
            }
        }
        ret += `        Ok(${func.astTypeName} {\n`;
        for (const element of func.elements.sort()) {
            if (element.kind !== "terminal") {
                ret += `            ${element.astTypeName},\n`;
            }
        }
        ret += `        })\n`;
        ret += `    }\n`;
        return ret;
    }

    private generateHookParserFunction(func: HookParserFunction): string {
        return `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;\n`;
    }

    public generateASTType(ir: IR): string {
        let decls = [];
        for (const element of ir.sort()) {
            switch (element.kind) {
                case "branch":
                    decls.push(this.generateBranchASTType(element));
                    break;
                case "product":
                    decls.push(this.generateProductASTType(element));
                    break;
                case "hook":
                    decls.push(this.generateHookASTType(element));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_ast.rs"\n`;
        ret += `// ==========================================\n\n`;
        ret += `#![allow(non_snake_case)]\n`;
        ret += `#![allow(clippy::large_enum_variant)]   // TODO: delete this line\n`;
        ret += `#![allow(nonstandard_style)]\n\n`;
        ret += `use crate::compiler::arena::{ArenaBox, ArenaIter};\n`;
        ret += `use crate::parser::ast_node::ASTNode;\n`;
        ret += `use crate::parser::ast_node::SyncPointBitMap;\n`;
        ret += `use crate::parser::errors::ParseErr;\n`;
        ret += `use crate::tokenizer::tokens::{Token, Delimiter, Keyword, Operator};\n\n`;
        ret += decls.join("");
        return ret;
    }

    private generateBranchASTType(func: BranchParserFunction): string {
        let ret = "";
        ret += `#[derive(Copy, Clone, Debug, std::hash::Hash, PartialEq, Eq)]\n`;
        ret += `pub enum ${func.astTypeName} {\n`;

        const allVariants = [
            ...func.branchesJudgebleInPeek0,
            ...func.branchesJudgebleInPeek1,
            ...(func.branchesFallbackInPeek1 || []),
            ...func.branchesNeedBacktrack
        ];
        let dublicateRemoved = [...new Set(allVariants.map(branch => branch.astTypeName))];

        for (const typeName of dublicateRemoved.sort()) {
            const isBoxed = allVariants.some(branch => branch.astTypeName === typeName && branch.isBoxed);
            if (isBoxed) {
                ret += `    ${typeName}(ArenaBox<${typeName}>),\n`;
            } else {
                ret += `    ${typeName}(${typeName}),\n`;
            }
        }
        ret += `    Invalid,\n`;
        ret += `}\n\n`;

        ret += `impl ASTNode for ${func.astTypeName} {\n`;
        const hasIdentifier = func.syncPointsTerminals.some(t => t.includes("Identifier"));
        const syncPoints = func.syncPointsTerminals.filter(t => !t.includes("$") && !t.includes("_")).join(", ");
        ret += `    const SYNC_POINT_SETS: SyncPointBitMap = SyncPointBitMap::build_map(${hasIdentifier}, &[${syncPoints}]);\n`;
        ret += `    fn get_error_situation(err: ParseErr) -> Option<Self> {\n`;
        ret += `        Some(Self::Invalid)\n`;
        ret += `    }\n`;
        ret += `}\n\n`;
        return ret;
    }

    private generateProductASTType(func: ProductParserFunction): string {
        let ret = "";
        const isManual = func.elements.some(element => element.kind === "terminal" && element.tokenTypeName.includes("$"));
        if (isManual) {
            ret += `pub use crate::parser::manual_ast::${func.astTypeName};\n\n`;
            return ret;
        }
        ret += `#[derive(Copy, Clone, Debug, std::hash::Hash, PartialEq, Eq)]\n`;
        ret += `pub struct ${func.astTypeName} {\n`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `    pub ${element.astTypeName}: ${element.astTypeName},\n`;
                    break;
                case "boxed":
                    ret += `    pub ${element.astTypeName}: ArenaBox<${element.astTypeName}>,\n`;
                    break;
                case "option":
                    ret += `    pub ${element.astTypeName}: Option<${element.astTypeName}>,\n`;
                    break;
                case "optionWithBox":
                    ret += `    pub ${element.astTypeName}: ArenaBox<Option<${element.astTypeName}>>,\n`;
                    break;
                case "repeat":
                    ret += `    pub ${element.astTypeName}: ArenaIter<${element.astTypeName}>,\n`;
                    break;
            }
        }
        ret += `}\n\n`;
        ret += `impl ASTNode for ${func.astTypeName} {\n`;
        const hasIdentifier = func.syncPointsTerminals.some(t => t.includes("Identifier"));
        const syncPoints = func.syncPointsTerminals.filter(t => !t.includes("$")).join(", ");
        ret += `    const SYNC_POINT_SETS: SyncPointBitMap = SyncPointBitMap::build_map(${hasIdentifier}, &[${syncPoints}]);\n`;
        ret += `    fn get_error_situation(err: ParseErr) -> Option<Self> {\n`;
        ret += `        None\n`;
        ret += `    }\n`;
        ret += `}\n\n`;
        return ret;
    }

    private generateHookASTType(func: HookParserFunction): string {
        return `pub use crate::parser::manual_ast::${func.astTypeName};\n\n`;
    }
}

export function generate(ir: IR): [string, string] {
    const gen = new Generator();
    return [
        gen.generateParser(ir),
        gen.generateASTType(ir)
    ]
}
