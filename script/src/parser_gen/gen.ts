import { BranchParserFunction, ProductParserFunction, HookParserFunction, IR } from "./ir";

class Generator {
    public generateParser(ir: IR): string {
        const funcs = [];
        for (const func of ir) {
            switch (func.kind) {
                case "branch":
                    funcs.push(this.generateBranchParseFunction(func));
                    break;
                case "product":
                    funcs.push(this.generateProductParserFunction(func));
                    break;
                case "hook":
                    funcs.push(this.generateHookParserFunction(func));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_parser.rs"\n`;
        ret += `// ==========================================\n\n`;
        ret += `use crate::compiler::symbol::Symbol;\n`;
        ret += `use crate::parser::base_parser::BaseParser;\n`;
        ret += `use crate::parser::errors::IParseErr;\n`;
        ret += `use crate::tokenizer::tokens::{Delimiter, Keyword, Literal, Operator, Comment, Token};\n\n`;
        ret += `#[allow(clippy::wildcard_imports)]\n`;
        ret += `use crate::parser::generated_ast::*;\n\n`;
        ret += `#[allow(non_snake_case)]\n`;
        ret += `pub trait GeneratedParser: BaseParser + Sized {`;
        ret += funcs.join("");
        ret += `}`;
        return ret;
    }

    private generateBranchParseFunction(func: BranchParserFunction): string {
        let ret = "";
        ret += `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {\n`;

        // Handle empty branches (edge case)
        if (func.branchesJudgebleInPeek0.length === 0 &&
            func.branchesJudgebleInPeek1.length === 0 &&
            (func.branchesFallbackInPeek1 || []).length === 0 &&
            func.branchesNeedBacktrack.length === 0) {
            ret += `        Err(Self::Error::build(self.get_errors_arena(), false, &[], self.enviroment()))\n`;
            ret += `    }\n`;
            return ret;
        }

        ret += `        match self.peek::<0>() {\n`;

        // 1. Simple Peek<0> matches
        for (const branch of func.branchesJudgebleInPeek0.sort()) {
            if (branch.isBoxed) {
                ret += `            Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.alloc_box(|this| this.parse_${branch.astTypeName}())?)),\n`;
            } else {
                ret += `            Some(${branch.firstTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),\n`;
            }
        }

        // 2. Complex matches (Peek<1> required or Backtrack required)
        const complexFirstTerminals = [...new Set([
            ...func.branchesJudgebleInPeek1.map(b => b.firstTerminal),
            ...func.branchesNeedBacktrack.map(b => b.firstTerminal),
            ...(func.branchesFallbackInPeek1 || []).map(b => b.firstTerminal)
        ])];

        for (const t0 of complexFirstTerminals.sort()) {
            ret += `            Some(${t0.replace(/\$.*\$/, "_")}) => {\n`;
            ret += `                match self.peek::<1>() {\n`;

            const peek1 = func.branchesJudgebleInPeek1.filter(b => b.firstTerminal === t0);
            for (const branch of peek1.sort()) {
                if (branch.isBoxed) {
                    ret += `                    Some(${branch.secondTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.alloc_box(|this| this.parse_${branch.astTypeName}())?)),\n`;
                } else {
                    ret += `                    Some(${branch.secondTerminal.replace(/\$.*\$/, "_")}) => Ok(${func.astTypeName}::${branch.astTypeName}(self.parse_${branch.astTypeName}()?)),\n`;
                }
            }

            const backtrack = func.branchesNeedBacktrack.filter(b => b.firstTerminal === t0);
            if (backtrack.length > 0) {
                ret += `                    _ => {\n`;
                for (const b of backtrack) {
                    ret += `                        if let Ok(node) = self.backtrack(|this| this.parse_${b.astTypeName}()) {\n`;
                    ret += `                            return Ok(${func.astTypeName}::${b.astTypeName}(node));\n`;
                    ret += `                        };\n`;
                }
                ret += `                        Err(Self::Error::build(self.get_errors_arena(), false, &[], self.enviroment()))`;
                ret += `                    }\n`;
            } else {
                const fallback = (func.branchesFallbackInPeek1 || []).find(b => b.firstTerminal === t0);
                if (fallback) {
                    if (fallback.isBoxed) {
                        ret += `                    _ => Ok(${func.astTypeName}::${fallback.astTypeName}(self.alloc_box(|this| this.parse_${fallback.astTypeName}())?),\n`;
                    } else {
                        ret += `                    _ => Ok(${func.astTypeName}::${fallback.astTypeName}(self.parse_${fallback.astTypeName}()?)),\n`;
                    }
                } else {
                    ret += `                    _ => Err(Self::Error::build(self.get_errors_arena(), false, &[], self.enviroment())),\n`;
                }
            }

            ret += `                }\n`;
            ret += `            },\n`;
        }

        // 3. Error Case
        ret += `            _ => Err(Self::Error::build(\n`;
        ret += `                self.get_errors_arena(),\n`;
        ret += `                ${func.expectedTerminals.some(t => t.includes("$")) ? "true" : "false"},\n`;
        const expected = [...new Set(func.expectedTerminals.filter(t => !t.includes("$") && !t.includes("_")))];
        ret += `                &[${expected.join(", ")}],\n`;
        ret += `                self.enviroment(),\n`;
        ret += `            )),\n`;

        ret += `        }\n`;
        ret += `    }\n`;
        return ret;
    }

    private generateProductParserFunction(func: ProductParserFunction): string {
        let ret = "";
        let isManual = func.elements.some(element => element.kind === "terminal" && element.tokenTypeName.includes("$"));
        if (isManual) {
            ret += `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;\n`;
            return ret;
        }
        ret += `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error> {\n`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `        let v_${element.astTypeName} = self.parse_${element.astTypeName}()?;\n`;
                    break;
                case "boxed":
                    ret += `        let v_${element.astTypeName} = self.alloc_box(|this| this.parse_${element.astTypeName}())?;\n`;
                    break;
                case "option":
                    ret += `        let v_${element.astTypeName} = self.parse_${element.astTypeName}().ok();\n`;
                    break;
                case "repeat":
                    ret += `        let v_${element.astTypeName} = self.repeat(Self::parse_${element.astTypeName})?;\n`;
                    break;
                case "optionWithBox":
                    ret += `        let v_${element.astTypeName} = self.alloc_box(Self::parse_${element.astTypeName}).ok();\n`;
                    break;
                case "terminal":
                    if (!element.tokenTypeName.includes("$")) {
                        ret += `        self.expect(&${element.tokenTypeName})?;\n`;
                    }
                    break;
            }
        }
        ret += `        Ok(${func.astTypeName} {\n`;
        for (const element of func.elements.sort()) {
            if (element.kind !== "terminal") {
                ret += `            ${element.astTypeName}: v_${element.astTypeName},\n`;
            }
        }
        ret += `        })\n`;
        ret += `    }\n`;
        return ret;
    }

    private generateHookParserFunction(func: HookParserFunction): string {
        return `\n    fn parse_${func.functionName}(&mut self) -> Result<${func.astTypeName}, Self::Error>;\n`;
    }

    public generateASTType(ir: IR): string {
        let decls = [];
        decls.push(this.generateVisitorTrait(ir));
        for (const element of ir.sort()) {
            switch (element.kind) {
                case "branch":
                    decls.push(this.generateBranchASTType(element));
                    break;
                case "product":
                    decls.push(this.generateProductASTType(element));
                    break;
                case "hook":
                    decls.push(this.generateHookASTType(element));
                    break;
            }
        }
        let ret = "";
        ret += `// ==========================================\n`;
        ret += `//  Generated by Script (see /script/index.ts)\n`;
        ret += `//  DO NOT EDIT THIS FILE DIRECTLY\n`;
        ret += `//  In "/src/parser/generated_ast.rs"\n`;
        ret += `// ==========================================\n\n`;
        ret += `#![allow(non_snake_case)]\n`;
        ret += `#![allow(clippy::large_enum_variant)]   // TODO: delete this line\n`;
        ret += `#![allow(nonstandard_style)]\n\n`;
        ret += `use crate::compiler::arena::{ArenaBox, ArenaIter};\n`;
        ret += `use crate::parser::ast_node::ASTNode;\n`;
        ret += `use crate::parser::ast_node::TokenBitMap;\n`;
        ret += `use crate::parser::errors::ParseErr;\n`;
        ret += `use crate::tokenizer::tokens::{Token, Delimiter, Keyword, Operator};\n\n`;
        ret += decls.join("");
        return ret;
    }

    private generateVisitorTrait(ir: IR): string {
        let ret = "";
        ret += `pub trait ASTVisitor {\n`;
        const elements = [...new Set(ir.map(({astTypeName}) => astTypeName))].sort((pre, curr) => pre.localeCompare(curr));
        for (const element of elements) {
            ret += `    fn visit_${element}(&mut self, node: &${element});\n`;
        }
        ret += `}\n\n`;

        return ret;
    }

    private generateBranchASTType(func: BranchParserFunction): string {
        let ret = "";
        ret += `#[derive(Copy, Clone, Debug, std::hash::Hash, PartialEq, Eq)]\n`;
        ret += `pub enum ${func.astTypeName} {\n`;

        const allVariants = [
            ...func.branchesJudgebleInPeek0,
            ...func.branchesJudgebleInPeek1,
            ...(func.branchesFallbackInPeek1 || []),
            ...func.branchesNeedBacktrack
        ];
        let dublicateRemoved = [...new Set(allVariants.map(branch => branch.astTypeName))].sort();

        for (const typeName of dublicateRemoved) {
            const isBoxed = allVariants.some(branch => branch.astTypeName === typeName && branch.isBoxed);
            if (isBoxed) {
                ret += `    ${typeName}(ArenaBox<${typeName}>),\n`;
            } else {
                ret += `    ${typeName}(${typeName}),\n`;
            }
        }
        ret += `    Invalid,\n`;
        ret += `}\n\n`;

        ret += `impl ASTNode for ${func.astTypeName} {\n`;
        const hasIdentifier = func.syncPointsTerminals.some(t => t.includes("Identifier"));
        const syncPoints = func.syncPointsTerminals.filter(t => !t.includes("$") && !t.includes("_")).join(", ");
        const firstHasIdentifier = func.firstTerminals.some(t => t.includes("Identifier"));
        const firstPoints = func.firstTerminals.filter(t => !t.includes("$")).join(", ");
        ret += `    const SYNC_POINT_SETS: TokenBitMap = TokenBitMap::build_map(${hasIdentifier}, &[${syncPoints}]);\n`;
        ret += `    const FIRST_SETS: TokenBitMap = TokenBitMap::build_map(${firstHasIdentifier}, &[${firstPoints}]);\n`;
        ret += `    fn get_error_situation(err: ParseErr) -> Option<Self> {\n`;
        ret += `        Some(Self::Invalid)\n`;
        ret += `    }\n\n`;
        ret += `    fn accept<V: ASTVisitor>(&self, visitor: &mut V) {\n`;
        ret += `        visitor.visit_${func.astTypeName}(self);\n`;
        ret += `    }\n`
        ret += `}\n\n`;

        ret += `impl ${func.astTypeName} {\n`;
        const everyVariants = (() => {
            const list = [...func.branchesFallbackInPeek1, ...func.branchesJudgebleInPeek0, ...func.branchesJudgebleInPeek1, ...func.branchesNeedBacktrack];
            const taken = [...new Map(
                list.map(item => {
                    const key = `${item.astTypeName}-${item.isBoxed}`;
                    return [key, { name: item.astTypeName, isBoxed: item.isBoxed }];
                })
            )];
            return [...new Set(taken)].map(v => v[1]).sort();
        })();
        for (const variant of everyVariants) {
            let returnType;
            if (variant.isBoxed) {
                returnType = "ArenaBox<" + variant.name + ">";
            } else {
                returnType = variant.name;
            }

            ret += `    pub fn expect_${variant.name}(&mut self) -> Option<&mut ${returnType}> {\n`;
            ret += `        match self {\n`;
            ret += `            Self::${variant.name}(v) => Some(&mut *v),\n`;
            ret += `            _ => None,\n`;
            ret += `        }\n`;
            ret += `    }\n\n`;
        }
        ret += `}\n`;

        return ret;
    }

    private generateProductASTType(func: ProductParserFunction): string {
        let ret = "";
        const isManual = func.elements.some(element => element.kind === "terminal" && element.tokenTypeName.includes("$"));
        if (isManual) {
            ret += `pub use crate::parser::manual_ast::${func.astTypeName};\n\n`;
            return ret;
        }
        ret += `#[derive(Copy, Clone, Debug, std::hash::Hash, PartialEq, Eq)]\n`;
        ret += `pub struct ${func.astTypeName} {\n`;
        for (const element of func.elements) {
            switch (element.kind) {
                case "normal":
                    ret += `    pub(super) ${element.astTypeName}: ${element.astTypeName},\n`;
                    break;
                case "boxed":
                    ret += `    pub(super) ${element.astTypeName}: ArenaBox<${element.astTypeName}>,\n`;
                    break;
                case "option":
                    ret += `    pub(super) ${element.astTypeName}: Option<${element.astTypeName}>,\n`;
                    break;
                case "optionWithBox":
                    ret += `    pub(super) ${element.astTypeName}: Option<ArenaBox<${element.astTypeName}>>,\n`;
                    break;
                case "repeat":
                    ret += `    pub(super) ${element.astTypeName}: ArenaIter<${element.astTypeName}>,\n`;
                    break;
            }
        }
        ret += `}\n\n`;
        ret += `impl ASTNode for ${func.astTypeName} {\n`;
        const syncHasIdentifier = func.syncPointsTerminals.some(t => t.includes("Identifier"));
        const syncPoints = func.syncPointsTerminals.filter(t => !t.includes("$")).join(", ");
        const firstHasIdentifier = func.firstTerminals.some(t => t.includes("Identifier"));
        const firstPoints = func.firstTerminals.filter(t => !t.includes("$")).join(", ");
        ret += `    const SYNC_POINT_SETS: TokenBitMap = TokenBitMap::build_map(${syncHasIdentifier}, &[${syncPoints}]);\n`;
        ret += `    const FIRST_SETS: TokenBitMap = TokenBitMap::build_map(${firstHasIdentifier}, &[${firstPoints}]);\n`;
        ret += `    fn get_error_situation(err: ParseErr) -> Option<Self> {\n`;
        ret += `        None\n`;
        ret += `    }\n\n`;
        ret += `    fn accept<V: ASTVisitor>(&self, visitor: &mut V) {\n`;
        ret += `        visitor.visit_${func.astTypeName}(self);\n`;
        ret += `    }\n`
        ret += `}\n\n`;


        ret += `impl ${func.astTypeName} {\n`;
        for (const typeName of func.elements
            .filter(element => element.kind !== "terminal")
            .sort()
        ) {
            let returnType;
            switch (typeName.kind) {
                case "boxed":
                    returnType = `ArenaBox<${typeName.astTypeName}>`;
                    break;
                case "option":
                    returnType = `Option<${typeName.astTypeName}>`;
                    break;
                case "optionWithBox":
                    returnType = `Option<ArenaBox<${typeName.astTypeName}>>`;
                    break;
                case "normal":
                    returnType = typeName.astTypeName;
                    break;
                case "repeat":
                    returnType = `ArenaIter<${typeName.astTypeName}>`;
                    break;
            }
            ret += `    pub fn ${typeName.astTypeName}(&self) -> &${returnType} {\n`;
            ret += `        &self.${typeName.astTypeName}\n`;
            ret += `    }\n\n`;
        }
        ret += `}\n`;

        return ret;
    }

    private generateHookASTType(func: HookParserFunction): string {
        return `pub use crate::parser::manual_ast::${func.astTypeName};\n\n`;
    }

    public generateAstPrinterImpl(ir: IR): string {
        let ret = "";
        ret += "use crate::compiler::arena::Arena;\n";
        ret += "use crate::parser::ast_node::ASTNode;\n";
        ret += "use crate::parser::generated_ast::*;\n";
        ret += "\n";
        ret += "pub struct ASTPrinter<'a> {\n";
        ret += "    arena: &'a Arena,\n";
        ret += "    indent: usize,\n";
        ret += "    out: String,\n";
        ret += "}\n";
        ret += "\n";
        ret += "impl<'a> ASTPrinter<'a> {\n";
        ret += "    pub fn new(arena: &'a Arena) -> Self {\n";
        ret += "        Self { arena, indent: 0, out: String::new() }\n";
        ret += "    }\n";
        ret += "\n";
        ret += "    fn write_indent(&mut self) {\n";
        ret += "        for _ in 0..self.indent { self.out.push_str(\"  \"); }\n";
        ret += "    }\n";
        ret += "\n";
        ret += "    pub fn load(&mut self) -> &str {\n";
        ret += "        &self.out\n";
        ret += "    }\n";
        ret += "}\n\n";
        ret += "#[allow(clippy::single_char_add_str)]\n";
        ret += `impl<'a> ASTVisitor for ASTPrinter<'a> {\n`;
        for (const func of ir) {
            ret += `    fn visit_${func.astTypeName}(&mut self, node: &${func.astTypeName}) {\n`;
            ret += `        self.write_indent();\n`;
            
            if (func.kind === "branch") {
                ret += `        self.out.push_str("${func.astTypeName}::");\n`;
                ret += `        match node {\n`;
                
                const variants = this.getUniqueVariants(func);
                for (const variant of variants) {
                    if (variant.isBoxed) {
                        ret += `            ${func.astTypeName}::${variant.name}(v) => {\n`;
                        ret += `                self.out.push_str("${variant.name}(\\n");\n`;
                        ret += `                self.indent += 1;\n`;
                        ret += `                v.get(self.arena).accept(self);\n`;
                        ret += `                self.indent -= 1;\n`;
                        ret += `                self.write_indent();\n`;
                        ret += `                self.out.push_str(")\\n");\n`;
                        ret += `            }\n`;
                    } else {
                        ret += `            ${func.astTypeName}::${variant.name}(v) => {\n`;
                        ret += `                self.out.push_str("${variant.name}(\\n");\n`;
                        ret += `                self.indent += 1;\n`;
                        ret += `                v.accept(self);\n`;
                        ret += `                self.indent -= 1;\n`;
                        ret += `                self.write_indent();\n`;
                        ret += `                self.out.push_str(")\\n");\n`;
                        ret += `            }\n`;
                    }
                }
                ret += `            ${func.astTypeName}::Invalid => self.out.push_str("Invalid\\n"),\n`;
                ret += `        }\n`;

            } else if (func.kind === "product") {
                ret += `        self.out.push_str("${func.astTypeName} {\\n");\n`;
                ret += `        self.indent += 1;\n`;

                for (const el of func.elements) {
                    if (el.kind === "terminal") continue;

                    ret += `        self.write_indent();\n`;
                    ret += `        self.out.push_str("${el.astTypeName}: ");\n`;

                    switch (el.kind) {
                        case "normal":
                            ret += `        self.out.push_str("\\n");\n`;
                            ret += `        node.${el.astTypeName}.accept(self);\n`;
                            break;
                        case "boxed":
                            ret += `        self.out.push_str("(Boxed)\\n");\n`;
                            ret += `        (node.${el.astTypeName}.get(self.arena)).accept(self);\n`;
                            break;
                        case "option":
                            ret += `if let Some(v) = &node.${el.astTypeName} { self.out.push_str("\\n"); v.accept(self); } else { self.out.push_str("None\\n"); }\n`;
                            break;
                        case "optionWithBox":
                            ret += `if let Some(v) = &node.${el.astTypeName} { self.out.push_str("(Boxed)\\n"); v.get(self.arena).accept(self); } else { self.out.push_str("None\\n"); }\n`;
                            break;
                        case "repeat":
                            ret += `        self.out.push_str("[\\n");\n`;
                            ret += `        self.indent += 1;\n`;
                            ret += `        for item in node.${el.astTypeName}.into_ref(self.arena) { item.accept(self); }\n`;
                            ret += `        self.indent -= 1;\n`;
                            ret += `        self.write_indent();\n`;
                            ret += `        self.out.push_str("],\\n");\n`;
                            break;
                    }
                }

                ret += `        self.indent -= 1;\n`;
                ret += `        self.write_indent();\n`;
                ret += `        self.out.push_str("}\\n");\n`;

            } else if (func.kind === "hook") {
                ret += `        self.out.push_str("<HookedNode:${func.astTypeName}>\\n");\n`;
            }

            ret += `    }\n\n`;
        }
        ret += `}`
        return ret;
    }

    private getUniqueVariants(func: BranchParserFunction) {
        const list = [
            ...func.branchesJudgebleInPeek0,
            ...func.branchesJudgebleInPeek1,
            ...(func.branchesFallbackInPeek1 || []),
            ...func.branchesNeedBacktrack
        ];
        const map = new Map();
        for (const item of list) {
            map.set(item.astTypeName, { name: item.astTypeName, isBoxed: item.isBoxed });
        }
        return Array.from(map.values()).sort((a, b) => a.name.localeCompare(b.name));
    }
}

export function generate(ir: IR): [string, string, string] {
    const gen = new Generator();
    return [
        gen.generateParser(ir),
        gen.generateASTType(ir),
        gen.generateAstPrinterImpl(ir),
    ]
}
