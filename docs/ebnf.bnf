<grammer> ::= <top_level>

<top_level> ::= { <top_level_statement> } 

<top_level_statement> ::= 
        <import_declaration>
      | <static_variable_declaration>
      | <class_declaration>
      | <enum_declaration>
      | <struct_declaration>
      | <function_declaration>
      | <protocol_declaration>
      | <module_declaration>
      | <annotation>
      | <type_alias_declaration>

<import_declaration> ::= "import" ( "{"  { <IDENTIFIER> "," } <IDENTIFIER> "}" ) | "*" "as" <IDENTIFIER> "from" <STRING_LITERAL> ";"

<static_variable_declaration> ::= <docs_comments> <is_public> "static" <IDENTIFIER> "=" <expression> ";"

<class_declaration> ::= <docs_comments> <is_public> "class" <IDENTIFIER> <generics> <implements_prptocol> "{" { <function_declaration> | <field_declaration> | <type_alias_declaration> } "}" 

<enum_declaration> ::= <docs_comments> <is_public> "enum" <IDENTIFIER> <generics> <implements_prptocol> "{" { ( <IDENTIFIER> ( "(" <type_literal> { "," <type_literal> } ")" )? ) | <function_declaration> } "}"

<struct_declaration> ::= <docs_comments> <is_public> "struct" <IDENTIFIER> 
    "{" <IDENTIFIER> ":" <type_literal> { "," <IDENTIFIER> ":" <type_literal> } "}"
    | "(" <type_literal> { "," <type_literal> } ")"
    | ";"

<function_declaration> ::= <docs_comments> "extern"? <is_public> "async"? "fn" <IDENTIFIER> <generics> "(" <params_with_types>  ")" ( ":" <type_literal> )? "panics"? <block_expression>

<protocol_declaration> ::= <docs_comments> <is_public> "protocol" <IDENTIFIER> <implements_protocol> "{" ( <function_declaration> | <virtual_function_declaration> | <type_alias_declaration> ) "}"

<module_declaration> ::= <docs_comments> <is_public> "module" <IDENTIFIER> "{" <top_level> "}"

<annotation> ::= "@" <IDENTIFIER> { <literal> }

<type_alias_declaration> ::= <docs_comments> <is_public> "type" <IDENTIFIER> <generics>? "=" <type_literal> ";"

<if_expression> ::= "if" <expression> <block_expression> { "else" "if" <expression> <block_expression> } ( "else" <block_expression> )?

<match_expression> ::= "match" <expression> "{" { <match_arm> } "}"
<match_arm> ::= <pattern> ( "if" <expression> ) "=>" <expression>

<loop_expression> ::= "loop" <expression>? <block_expression>

<while_expression> ::= "while" <expression> <block_expression>

<for_statement> ::= "for" <IDENTIFIER> "in" <expression> <block_expression>

<for_expression> ::= "for" <expression> "{" { <pipeline> } "}"
<pipeline> ::= "|>" <pattern> "=>" <expression>

<if_let_expression> ::= "if" "let" <pattern> "=" <expression> <block_expression>
<while_let_expression> ::= "while" "let" <pattern> "=" <expression> <block_expression>

<pipe_expression> ::= "pipe" <expression> "{" { "|>" <pattern> ("if" <expression>)? "=>" <block_expression> | <expression> } "}"

<closer> ::= "(" ( <param_with_type> | <IDENTIFIER> { "," <param_with_type> | <IDENTIFIER> } )? ")" "->" <block_expression>

<accesser> ::= <IDENTIFIER> { "::" <IDENTIFIER> } 

<params> ::= ( <expression> { "," <expression> } )?

<expression> ::= <term>  { <ADD_LEVEL_BINARY_OPERATOR> <term> }

<term> ::= <factor> { <MULTI_LEVEL_BINARY_OPERATOR> <factor> }
<factor> ::= <UNARY_OPERATOR>? <primary>
<primary> ::= 
      <block_expression>
    | <if_expression>
    | <match_expression>
    | <loop_expression>
    | <while_expression>
    | <for_expression>
    | <pipe_expression>
    | <accesser>
    | <literal>
    | "try"? <accesser> "(" <params> ")"
    | "try"? <accesser> "." <IDENTIFIER> "(" <params> ")"
    | <accesser> "." <IDENTIFIER> 
    | "await" <expression>
    | "(" ( <expression> { "," <expression> } )? ")"
    | <accesser> "{" ( (<IDENTIFIER> ":" <expression>) | <IDENTIFIER> { "," ( <IDENTIFIER> ":" <expression> ) | <IDENTIFIER> } )? "}"
    | <closer>
    | <if_let_expression>
    | <while_let_expression>
    | "[" (<expression> { "," <expression> } )? "]"
    | <expression> "[" <expression> "]"
    | <expression> "as" <type_literal>

<statement> ::= 
      <if_expression>
    | <match_expression>
    | <loop_expression>
    | <while_expression>
    | <for_statement>
    | "ignore"? <expression> ";"
    | "let" | "const" <pattern> ( ":" <type_literal> ) ( <ASSIGMENT_OPERATOR> <expression> )? ";"
    | "return" <expression> ";"
    | "break" <expression> ";"
    | "continue" ";"
    | <accesser> <ASSIGMENT_OPERATOR> <expression> ";"

<field_declaration> ::= ( "final" | "mut" ) <IDENTIFIER> ":" <type_literal> ";"

<virtual_function_declaration> ::= "async" "fn" <IDENTIFIER> <generics>? "(" <params_with_types> ")" ( ":" <type_literal> ) "panics"? ";"

<param_with_type> ::= "mut"? (<IDENTIFIER> ":" <type_literal> ( "=" <expression> )? ) | "this"

<params_with_types> ::= { <param_with_type> "," } <param_with_type>

<block_expression> ::= "{" { <statement> } | <expression> "}"

<is_public> ::= "pub" | "";

<literal> ::= <STRING_LITERAL> | <CHAR_LITERAL> | <NUM_LITERAL> | <BOOL_LITERAL>

<type_literal> ::= 
      <accesser> ( "<" { <type_literal> "," } <type_literal>  ">" )?
    | "Bool"
    | "Int"
    | "DoubleInt"
    | "Float"
    | "DoubleFloat"
    | "Char"
    | "Usize"
    | "Any"
    | "(" ( <type_literal> { "," <type_literal> } )? ")"
    | "Never"
    | "Void"

<docs_comments> ::= { <DOCS_COMMENT> } { <annotation> }

<pattern> ::= 
      <IDENTIFIER> 
    | "_"
    | <accesser> "(" <pattern> { "," <pattern> } ")"
    | "(" ( <pattern> { "," <pattern> } )? ")"
    | <accesser> "{" { (<IDENTIFIER> ":" <pattern>) | (<IDENTIFIER>) } "}"
    | <literal>
    | <CHAR_LITERAL> ".." | "..=" <CHAR_LITERAL>
    | <NUM_LITERAL> ".." | "..=" <NUM_LITERAL>
    | <IDENTIFIER> "@" <pattern>
# TODO: add [ first, second, ... last ] like pattern

<generics> ::= "<" <IDENTIFIER> ":" <type_literal> { "&" <type_literal> } { "," <IDENTIFIER> ":" <type_literal> { "&" <type_literal> } } ">"

<implements_prptocol> ::= ( ":" <accesser> { "," <accesser> } )?

