$<grammer> ::= <top_level>

$<top_level> ::= { <top_level_statement> } 

$<top_level_statement> ::= 
        <import_declaration>
      | <static_variable_declaration>
      | <class_declaration>
      | <enum_declaration>
      | <struct_declaration>
      | <function_declaration>
      | <protocol_declaration>
      | <module_declaration>
      | <annotation>
      | <type_alias_declaration>

$<import_declaration> ::= "import" ( "{"  { <IDENTIFIER> "," } <IDENTIFIER> "}" ) | "*" "as" <IDENTIFIER> "from" <STRING_LITERAL> ";"

$<static_variable_declaration> ::= <docs_comments> <is_public> "static" <IDENTIFIER> "=" <expression> ";"

$<class_declaration> ::= <docs_comments> <is_public> "class" <IDENTIFIER> <generics> <implements_protocol> "{" { <function_declaration> | <field_declaration> | <type_alias_declaration> } "}" 

$<enum_declaration> ::= <docs_comments> <is_public> "enum" <IDENTIFIER> <generics> <implements_protocol> "{" { ( <IDENTIFIER> ( "(" <type_literal> { "," <type_literal> } ")" )? ) | <function_declaration> } "}"

$<struct_declaration> ::= ( <docs_comments> <is_public> "struct" <IDENTIFIER> )
    ( "{" { <field_declaration> } "}" )
    | ("(" <type_literal> { "," <type_literal> } ")")
    | ";"

$<function_declaration> ::= <docs_comments> "extern"? <is_public> "async"? "fn" <IDENTIFIER> <generics> "(" <params_with_types>  ")" ( ":" <type_literal> )? "panics"? <block_expression>?

$<protocol_declaration> ::= <docs_comments> <is_public> "protocol" <IDENTIFIER> <implements_protocol> "{" ( <function_declaration> | <type_alias_declaration> ) "}"

$<module_declaration> ::= <docs_comments> <is_public> "module" <IDENTIFIER> "{" <top_level> "}"

$<annotation> ::= "@" <IDENTIFIER> { <literal> }

$<type_alias_declaration> ::= <docs_comments> <is_public> "type" <IDENTIFIER> <generics>? "=" <type_literal> ";"

$<if_expression> ::= "if" <expression> <block_expression> { "else" "if" <expression> <block_expression> } ( "else" <block_expression> )?

$<match_expression> ::= "match" <expression> "{" { <match_arm> } "}"
$<match_arm> ::= <pattern> ( "if" <expression> ) "=>" <expression>

$<loop_expression> ::= "loop" <expression>? <block_expression>

$<while_expression> ::= "while" <expression> <block_expression>

$<for_statement> ::= "for" <pattern> "in" <expression> <block_expression>

$<for_expression> ::= "for" <expression> "{" { <pipeline> } "}"
$<pipeline> ::= "|>" <pattern> "=>" <expression>

$<if_let_expression> ::= "if" "let" <pattern> "=" <expression> <block_expression>
$<while_let_expression> ::= "while" "let" <pattern> "=" <expression> <block_expression>

$<pipe_expression> ::= "pipe" <expression> "{" { "|>" <pattern> ("if" <expression>)? "=>" <block_expression> | <expression> } "}"

$<closer> ::= "(" ( <param_with_type> | <IDENTIFIER> { "," <param_with_type> | <IDENTIFIER> } )? ")" "->" <block_expression>

$<accesser> ::= <IDENTIFIER> { "::" <IDENTIFIER> } 

$<params> ::= ( <expression> { "," <expression> } )?

$<expression> ::= <logical_or_expr>
$<logical_or_expr> ::= <logical_and_expr> "||" <logical_and_expr> 
$<logical_and_expr> ::= <bitwise_or_expr> "&&" <bitwise_or_expr>
$<bitwise_or_expr> ::= <bitwise_xor_expr> "|" <bitwise_xor_expr> 
$<bitwise_xor_expr> ::= <bitwise_and_expr> "^" <bitwise_and_expr> 
$<bitwise_and_expr> ::= <equality_expr> "&" <equality_expr>
$<equality_expr> ::= <relational_expr> ("==" | "!=") <relational_expr>
$<relational_expr> ::= <shift_expr>  ("<" | "<=" | ">" | ">=") <shift_expr> 
$<shift_expr> ::= <additive_expr>  ("<<" | ">>") <additive_expr> 
$<additive_expr> ::= <multiplicative_expr>  ("+" | "-") <multiplicative_expr> 
$<multiplicative_expr> ::= <power_expr> ("*" | "/" | "%") <power_expr> 
$<power_expr> ::= <prefix_expr>  "**" <power_expr> 
$<prefix_expr> ::= (("!" | "~") <prefix_expr>) | <primary_expr>
$<primary_expr> ::= 
      <block_expression>
    | <if_expression>
    | <match_expression>
    | <loop_expression>
    | <while_expression>
    | <for_expression>
    | <pipe_expression>
    | <accesser>
    | <literal>
    | "try"? <accesser> "(" <params> ")"
    | "try"? <accesser> "." <IDENTIFIER> "(" <params> ")"
    | <accesser> "." <IDENTIFIER> 
    | "await" <expression>
    | "(" ( <expression> { "," <expression> } )? ")"
    | <accesser> "{" ( ((<IDENTIFIER> ":" <expression>) | <IDENTIFIER>) { "," ( <IDENTIFIER> ":" <expression> ) | <IDENTIFIER> } )? "}"
    | <closer>
    | <if_let_expression>
    | <while_let_expression>
    | "[" (<expression> { "," <expression> } )? "]"
    | <expression> "[" <expression> "]"
    | <expression> "as" <type_literal>
    | "(" <expression> ")"

$<statement> ::= 
      <if_expression>
    | <match_expression>
    | <loop_expression>
    | <while_expression>
    | <for_statement>
    | "ignore"? <expression> ";"
    | "let" | "const" <pattern> ( ":" <type_literal> ) ( <ASSIGMENT_OPERATOR> <expression> )? ";"
    | "return" <expression> ";"
    | "break" <expression> ";"
    | "continue" ";"
    | <accesser> <ASSIGMENT_OPERATOR> <expression> ";"

$<field_declaration> ::= ( "final" | "mut" ) <IDENTIFIER> ":" <type_literal> ";"

$<param_with_type> ::= "mut"? (<IDENTIFIER> ":" <type_literal> ( "=" <expression> )? ) | "this"

$<params_with_types> ::= { <param_with_type> "," } <param_with_type>

$<block_expression> ::= "{" { <statement> } | <expression> "}"

$<is_public> ::= "pub" | "";

$<literal> ::= <STRING_LITERAL> | <CHAR_LITERAL> | <NUM_LITERAL> | <BOOL_LITERAL>

$<type_literal> ::= 
      <accesser> ( "<" { <type_literal> "," } <type_literal>  ">" )?
    | "impl" <type_literal>
    | "typeof" <expression>
    | "Bool"
    | "Int"
    | "DoubleInt"
    | "Float"
    | "DoubleFloat"
    | "Char"
    | "Usize"
    | "Any"
    | "(" ( <type_literal> { "," <type_literal> } )? ")"
    | "Never"
    | "Void"

$<docs_comments> ::= { <DOCS_COMMENT> } { <annotation> }

$<pattern> ::= 
      <IDENTIFIER> 
    | "_"
    | <accesser> "(" <pattern> { "," <pattern> } ")"
    | "(" ( <pattern> { "," <pattern> } )? ")"
    | <accesser> "{" { (<IDENTIFIER> ":" <pattern>) | (<IDENTIFIER>) } "}"
    | <accesser>
    | <literal>
    | <CHAR_LITERAL> ".." | "..=" <CHAR_LITERAL>
    | <NUM_LITERAL> ".." | "..=" <NUM_LITERAL>
    | <IDENTIFIER> "@" <pattern>
# TODO: add [ first, second, ... last ] like pattern

$<generics> ::= "<" <IDENTIFIER> ":" <type_literal> { "&" <type_literal> } { "," <IDENTIFIER> ":" (<type_literal> { "&" <type_literal> })? } ">"

$<implements_protocol> ::= ( ":" <accesser> { "," <accesser> } )?

# <IDENTIFIER>: identifier like es_2_d22
# <STRING_LITERAL>: string literal like "HelloWor\n\"ld"
# <CHAR_LITERAL>: char literal like '*' '\n' '\''
# <NUM_LITERAL>: number literal like 243 42.234 0xff 0b00101001 423.323e+2 
# <BOOL_LITERAL>: true or false
# <DOCS_COMMENT>: documentation comment like /// # This is title. \n it's content.
# <ASSIGNMENT_OPERATOR>: = -= += *= /= %= **= 
